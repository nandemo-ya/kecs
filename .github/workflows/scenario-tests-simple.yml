name: Scenario Tests (Simple Mode)

on:
  pull_request:
    paths:
      - 'tests/scenarios/**'
      - 'controlplane/**'
      - '.github/workflows/scenario-tests-simple.yml'
  workflow_dispatch:

permissions:
  contents: read
  pull-requests: write
  checks: write

jobs:
  test-simple:
    runs-on: [self-hosted, aws-testable, large]
    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: controlplane/go.mod

      - name: Install dependencies
        run: |
          cd controlplane
          go mod download
          go mod verify

      - name: Build KECS binary
        run: |
          cd controlplane
          go build -o ../bin/kecs ./cmd/controlplane
          chmod +x ../bin/kecs

      - name: Clean up any existing k3d clusters
        run: |
          k3d cluster list -o json | jq -r '.[].name' | grep '^kecs-' | xargs -r -I {} k3d cluster delete {} || true

      - name: Start KECS server
        run: |
          echo "Starting KECS server..."
          KECS_SECURITY_ACKNOWLEDGED=true ./bin/kecs server --port 8080 --admin-port 8081 > kecs-test.log 2>&1 &
          echo $! > kecs.pid
          
          echo "Waiting for KECS to be ready..."
          for i in {1..30}; do
            if curl -s http://localhost:8081/health > /dev/null; then
              echo "KECS is ready!"
              break
            fi
            echo "Waiting for KECS... ($i/30)"
            sleep 2
          done
          
          # Verify KECS is running
          if ! curl -s http://localhost:8081/health > /dev/null; then
            echo "KECS failed to start!"
            cat kecs-test.log
            exit 1
          fi

      - name: Setup test environment
        run: |
          cd tests/scenarios
          # Download test dependencies
          go mod download
          go mod tidy
          
          # Export environment variables for all test steps
          echo "KECS_ENDPOINT=http://localhost:8080" >> $GITHUB_ENV
          echo "KECS_ADMIN_ENDPOINT=http://localhost:8081" >> $GITHUB_ENV
          echo "KECS_TEST_MODE=simple" >> $GITHUB_ENV
          echo "KECS_LOG_LEVEL=info" >> $GITHUB_ENV

      - name: Run Phase 1 tests (Cluster Operations)
        id: phase1-tests
        run: |
          cd tests/scenarios
          echo "## Running Phase 1: Cluster Operations ##"
          go test -v ./phase1 -p 1 -timeout 10m -json | tee phase1-output.json || true
          go test -v ./phase1 -p 1 -timeout 10m 2>&1 | tee phase1-verbose.txt || true
          echo "phase1_exit_code=${PIPESTATUS[0]}" >> $GITHUB_OUTPUT

      - name: Run Phase 2 tests (Task Definitions and Services)
        id: phase2-tests
        if: always()
        run: |
          cd tests/scenarios
          echo "## Running Phase 2: Task Definitions and Services ##"
          go test -v ./phase2 -p 1 -timeout 10m -json | tee phase2-output.json || true
          go test -v ./phase2 -p 1 -timeout 10m 2>&1 | tee phase2-verbose.txt || true
          echo "phase2_exit_code=${PIPESTATUS[0]}" >> $GITHUB_OUTPUT

      - name: Run Phase 3 tests (Advanced Features)
        id: phase3-tests
        if: always()
        run: |
          cd tests/scenarios
          echo "## Running Phase 3: Advanced Features ##"
          go test -v ./phase3 -p 1 -timeout 10m -json | tee phase3-output.json || true
          go test -v ./phase3 -p 1 -timeout 10m 2>&1 | tee phase3-verbose.txt || true
          echo "phase3_exit_code=${PIPESTATUS[0]}" >> $GITHUB_OUTPUT

      - name: Combine test results
        if: always()
        run: |
          cd tests/scenarios
          # Combine JSON outputs
          cat phase1-output.json phase2-output.json phase3-output.json > test-output.json 2>/dev/null || true
          # Combine verbose outputs
          cat phase1-verbose.txt phase2-verbose.txt phase3-verbose.txt > test-output-verbose.txt 2>/dev/null || true
          
          # Calculate overall exit code
          PHASE1_EXIT=${{ steps.phase1-tests.outputs.phase1_exit_code || 0 }}
          PHASE2_EXIT=${{ steps.phase2-tests.outputs.phase2_exit_code || 0 }}
          PHASE3_EXIT=${{ steps.phase3-tests.outputs.phase3_exit_code || 0 }}
          OVERALL_EXIT=$((PHASE1_EXIT + PHASE2_EXIT + PHASE3_EXIT))
          if [ $OVERALL_EXIT -gt 0 ]; then
            echo "exit_code=1" >> $GITHUB_OUTPUT
          else
            echo "exit_code=0" >> $GITHUB_OUTPUT
          fi

      - name: Display test results summary
        if: always()
        run: |
          cd tests/scenarios
          echo "## Test Results Summary ##"
          
          # Phase 1 results
          echo "### Phase 1: Cluster Operations"
          if [ -f phase1-verbose.txt ]; then
            grep -E "^(ok|FAIL)\s+github\.com.*phase1" phase1-verbose.txt || echo "No phase1 results found"
            grep -E "^--- FAIL:" phase1-verbose.txt | head -5 || true
          fi
          echo ""
          
          # Phase 2 results  
          echo "### Phase 2: Task Definitions and Services"
          if [ -f phase2-verbose.txt ]; then
            grep -E "^(ok|FAIL)\s+github\.com.*phase2" phase2-verbose.txt || echo "No phase2 results found"
            grep -E "^--- FAIL:" phase2-verbose.txt | head -5 || true
          fi
          echo ""
          
          # Phase 3 results
          echo "### Phase 3: Advanced Features"
          if [ -f phase3-verbose.txt ]; then
            grep -E "^(ok|FAIL)\s+github\.com.*phase3" phase3-verbose.txt || echo "No phase3 results found"
            grep -E "^--- FAIL:" phase3-verbose.txt | head -5 || true
          fi

      - name: Stop KECS server
        if: always()
        run: |
          if [ -f kecs.pid ]; then
            echo "Stopping KECS server..."
            kill $(cat kecs.pid) || true
            rm kecs.pid
          fi

      - name: Clean up k3d clusters
        if: always()
        run: |
          echo "Cleaning up k3d clusters..."
          k3d cluster list -o json | jq -r '.[].name' | grep '^kecs-' | xargs -r -I {} k3d cluster delete {} || true

      - name: Upload test artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: |
            kecs-test.log
            tests/scenarios/test-output.json
            tests/scenarios/test-output-verbose.txt
            tests/scenarios/phase1-*.txt
            tests/scenarios/phase2-*.txt
            tests/scenarios/phase3-*.txt
            tests/scenarios/phase1-*.json
            tests/scenarios/phase2-*.json
            tests/scenarios/phase3-*.json

      - name: Parse and comment test results
        uses: actions/github-script@v7
        if: always() && github.event_name == 'pull_request'
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            
            // Read test output
            let testResults = [];
            try {
              const output = fs.readFileSync('tests/scenarios/test-output.json', 'utf8');
              const lines = output.split('\n').filter(line => line.trim());
              testResults = lines.map(line => {
                try {
                  return JSON.parse(line);
                } catch (e) {
                  return null;
                }
              }).filter(r => r !== null);
            } catch (e) {
              console.error('Failed to read test output:', e);
            }
            
            // Parse results
            let totalTests = 0;
            let passedTests = 0;
            let failedTests = 0;
            let skippedTests = 0;
            let totalDuration = 0;
            const failures = [];
            const slowTests = [];
            const failureDetails = new Map(); // Track detailed failure info
            
            testResults.forEach(result => {
              if (result.Action === 'pass' && result.Test) {
                passedTests++;
                totalTests++;
                if (result.Elapsed && result.Elapsed > 10) {
                  slowTests.push({
                    name: result.Test,
                    package: result.Package,
                    duration: result.Elapsed
                  });
                }
              } else if (result.Action === 'fail' && result.Test) {
                failedTests++;
                totalTests++;
                const key = `${result.Package}::${result.Test}`;
                if (!failureDetails.has(key)) {
                  failureDetails.set(key, {
                    name: result.Test,
                    package: result.Package,
                    outputs: []
                  });
                }
              } else if (result.Action === 'skip' && result.Test) {
                skippedTests++;
                totalTests++;
              } else if (result.Action === 'output' && result.Test) {
                // Collect output for failed tests
                const key = `${result.Package}::${result.Test}`;
                if (failureDetails.has(key)) {
                  failureDetails.get(key).outputs.push(result.Output);
                }
              }
              
              if (result.Action === 'pass' && !result.Test && result.Elapsed) {
                totalDuration += result.Elapsed;
              }
            });
            
            // Convert failure details to array
            failureDetails.forEach(failure => {
              failures.push({
                name: failure.name,
                package: failure.package,
                output: failure.outputs.join('')
              });
            });
            
            // Sort slow tests
            slowTests.sort((a, b) => b.duration - a.duration);
            
            // Format duration
            function formatDuration(seconds) {
              if (seconds < 60) {
                return `${seconds.toFixed(1)}s`;
              }
              const minutes = Math.floor(seconds / 60);
              const secs = (seconds % 60).toFixed(0);
              return `${minutes}m ${secs}s`;
            }
            
            // Parse phase results
            const phaseResults = {
              phase1: { passed: 0, failed: 0, skipped: 0, total: 0 },
              phase2: { passed: 0, failed: 0, skipped: 0, total: 0 },
              phase3: { passed: 0, failed: 0, skipped: 0, total: 0 }
            };
            
            testResults.forEach(result => {
              if (result.Test && result.Package) {
                let phase = null;
                if (result.Package.includes('phase1')) phase = 'phase1';
                else if (result.Package.includes('phase2')) phase = 'phase2';
                else if (result.Package.includes('phase3')) phase = 'phase3';
                
                if (phase) {
                  if (result.Action === 'pass') {
                    phaseResults[phase].passed++;
                    phaseResults[phase].total++;
                  } else if (result.Action === 'fail') {
                    phaseResults[phase].failed++;
                    phaseResults[phase].total++;
                  } else if (result.Action === 'skip') {
                    phaseResults[phase].skipped++;
                    phaseResults[phase].total++;
                  }
                }
              }
            });
            
            // Build comment
            let comment = '## 🧪 Scenario Test Results (Simple Mode)\n\n';
            
            // Summary
            comment += '### Overall Summary\n';
            comment += `- Total Tests: ${totalTests}\n`;
            comment += `- ✅ Passed: ${passedTests}\n`;
            comment += `- ❌ Failed: ${failedTests}\n`;
            comment += `- ⏭️ Skipped: ${skippedTests}\n`;
            comment += `- ⏱️ Total Duration: ${formatDuration(totalDuration)}\n\n`;
            
            // Phase breakdown
            comment += '### Results by Phase\n';
            comment += '| Phase | Total | ✅ Passed | ❌ Failed | ⏭️ Skipped |\n';
            comment += '|-------|-------|-----------|-----------|------------|\n';
            comment += `| Phase 1: Cluster Operations | ${phaseResults.phase1.total} | ${phaseResults.phase1.passed} | ${phaseResults.phase1.failed} | ${phaseResults.phase1.skipped} |\n`;
            comment += `| Phase 2: Task Definitions | ${phaseResults.phase2.total} | ${phaseResults.phase2.passed} | ${phaseResults.phase2.failed} | ${phaseResults.phase2.skipped} |\n`;
            comment += `| Phase 3: Advanced Features | ${phaseResults.phase3.total} | ${phaseResults.phase3.passed} | ${phaseResults.phase3.failed} | ${phaseResults.phase3.skipped} |\n`;
            comment += '\n';
            
            if (failedTests === 0 && totalTests > 0) {
              comment += '### ✅ All tests passed!\n\n';
            } else if (failedTests > 0) {
              comment += '### ❌ Failed Tests\n\n';
              
              // Group failures by package
              const failuresByPackage = {};
              failures.forEach(failure => {
                const pkgName = failure.package.split('/').pop(); // Get last part of package name
                if (!failuresByPackage[pkgName]) {
                  failuresByPackage[pkgName] = [];
                }
                failuresByPackage[pkgName].push(failure);
              });
              
              // List all failed tests first for quick overview
              comment += '#### Failed Test List:\n';
              Object.keys(failuresByPackage).sort().forEach(pkg => {
                comment += `\n**${pkg}:**\n`;
                failuresByPackage[pkg].forEach(failure => {
                  comment += `- ❌ ${failure.name}\n`;
                });
              });
              comment += '\n';
              
              // Then provide detailed output in collapsible sections
              comment += '<details>\n<summary>Detailed Failure Output</summary>\n\n';
              Object.keys(failuresByPackage).sort().forEach(pkg => {
                comment += `### ${pkg}\n\n`;
                failuresByPackage[pkg].forEach(failure => {
                  comment += `<details>\n<summary>${failure.name}</summary>\n\n`;
                  if (failure.output) {
                    // Limit output to last 50 lines to avoid huge comments
                    const lines = failure.output.split('\n');
                    const outputToShow = lines.length > 50 
                      ? '... (truncated)\n' + lines.slice(-50).join('\n')
                      : failure.output;
                    comment += '```\n' + outputToShow + '\n```\n';
                  }
                  comment += '</details>\n\n';
                });
              });
              comment += '</details>\n\n';
            }
            
            // Slow tests
            if (slowTests.length > 0) {
              comment += '### 🐌 Slow Tests (>10s)\n\n';
              comment += '| Test | Duration |\n';
              comment += '|------|----------|\n';
              slowTests.slice(0, 10).forEach(test => {
                const shortName = test.name.length > 60 
                  ? test.name.substring(0, 57) + '...' 
                  : test.name;
                comment += `| ${shortName} | ${formatDuration(test.duration)} |\n`;
              });
              comment += '\n';
            }
            
            comment += '---\n';
            comment += '_Running with single KECS instance (simple mode) for better performance and stability._';
            
            // Post comment
            try {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment
              });
              console.log('Successfully posted test results to PR');
            } catch (error) {
              console.error('Failed to post comment:', error);
            }