name: Scenario Tests

on:
  pull_request:
    paths:
      - 'tests/scenarios/**'
      - 'controlplane/**'
      - '.github/workflows/scenario-tests.yml'
  workflow_dispatch:

permissions:
  contents: read
  pull-requests: write
  checks: write

jobs:
  test-phases:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: tests/scenarios/go.mod

      - name: Download dependencies
        run: |
          cd tests/scenarios
          go mod download
          go mod tidy

      - name: Install AWS CLI v2
        uses: unfor19/install-aws-cli-action@v1
        with:
          version: 2
          verbose: false
          arch: amd64

      - name: Build KECS Docker image
        run: |
          cd controlplane
          docker build -t kecs:test .

      - name: Run Phase 1 tests (Foundation)
        id: test-phase1
        run: |
          cd tests/scenarios
          echo "## Running Phase 1: Foundation tests ##"
          go run github.com/onsi/ginkgo/v2/ginkgo -v -timeout 30m \
            --no-color \
            --junit-report=junit-phase1.xml \
            --output-dir=. \
            ./cluster/... | tee test-output-phase1.log
          
          # Capture exit code
          echo "exit_code=$?" >> $GITHUB_OUTPUT
        env:
          KECS_LOG_LEVEL: info

      - name: Run Phase 2 tests (Core Operations)
        id: test-phase2
        if: success() || failure()
        run: |
          cd tests/scenarios
          echo "## Running Phase 2: Core Operations tests ##"
          go run github.com/onsi/ginkgo/v2/ginkgo -v -timeout 30m \
            --no-color \
            --junit-report=junit-phase2.xml \
            --output-dir=. \
            ./task_definition/... ./service/... | tee test-output-phase2.log
          
          # Capture exit code
          echo "exit_code=$?" >> $GITHUB_OUTPUT
        env:
          KECS_LOG_LEVEL: info

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-all-phases
          path: |
            tests/scenarios/junit-*.xml
            tests/scenarios/test-output-*.log

      - name: Test Report - Phase 1
        uses: dorny/test-reporter@v1
        if: always() && github.event_name == 'pull_request'
        with:
          name: Phase 1 - Foundation Tests
          path: tests/scenarios/junit-phase1.xml
          reporter: java-junit
          fail-on-error: false

      - name: Test Report - Phase 2
        uses: dorny/test-reporter@v1
        if: always() && github.event_name == 'pull_request'
        with:
          name: Phase 2 - Core Operations Tests
          path: tests/scenarios/junit-phase2.xml
          reporter: java-junit
          fail-on-error: false

      - name: Comment PR with test results
        uses: actions/github-script@v7
        if: always() && github.event_name == 'pull_request'
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');
            
            // Function to parse test output
            function parseTestOutput(filename, phaseName) {
              let testOutput = '';
              try {
                testOutput = fs.readFileSync(filename, 'utf8');
                // Remove ANSI escape codes for cleaner output
                testOutput = testOutput.replace(/\x1b\[[0-9;]*m/g, '');
              } catch (e) {
                return null;
              }
              
              const summaryMatch = testOutput.match(/Ran (\d+) of (\d+) Specs in .*/);
              const passedMatch = testOutput.match(/(\d+) Passed/);
              const failedMatch = testOutput.match(/(\d+) Failed/);
              const pendingMatch = testOutput.match(/(\d+) Pending/);
              const skippedMatch = testOutput.match(/(\d+) Skipped/);
              
              return {
                phase: phaseName,
                total: summaryMatch ? parseInt(summaryMatch[2]) : 0,
                ran: summaryMatch ? parseInt(summaryMatch[1]) : 0,
                passed: passedMatch ? parseInt(passedMatch[1]) : 0,
                failed: failedMatch ? parseInt(failedMatch[1]) : 0,
                pending: pendingMatch ? parseInt(pendingMatch[1]) : 0,
                skipped: skippedMatch ? parseInt(skippedMatch[1]) : 0,
                output: testOutput
              };
            }
            
            // Parse outputs from all phases
            const phase1 = parseTestOutput('tests/scenarios/test-output-phase1.log', 'Phase 1: Foundation');
            const phase2 = parseTestOutput('tests/scenarios/test-output-phase2.log', 'Phase 2: Core Operations');
            
            // Combine results
            const phases = [phase1, phase2].filter(p => p !== null);
            
            let summary = '## ðŸ§ª Scenario Test Results\n\n';
            
            // Overall summary
            let totalPassed = 0, totalFailed = 0, totalRan = 0, totalSpecs = 0;
            phases.forEach(phase => {
              totalPassed += phase.passed;
              totalFailed += phase.failed;
              totalRan += phase.ran;
              totalSpecs += phase.total;
            });
            
            summary += `### Overall Summary\n`;
            summary += `- Total Specs: ${totalSpecs}\n`;
            summary += `- Total Ran: ${totalRan}\n`;
            summary += `- âœ… Total Passed: ${totalPassed}\n`;
            summary += `- âŒ Total Failed: ${totalFailed}\n\n`;
            
            if (totalFailed === 0 && totalRan > 0) {
              summary += '### âœ… All tests passed!\n\n';
            } else if (totalFailed > 0) {
              summary += '### âŒ Some tests failed\n\n';
            }
            
            // Phase-by-phase breakdown
            summary += '### Phase Results\n\n';
            phases.forEach(phase => {
              const status = phase.failed === 0 ? 'âœ…' : 'âŒ';
              summary += `**${phase.phase}** ${status}\n`;
              summary += `- Specs: ${phase.total} | Ran: ${phase.ran} | Passed: ${phase.passed} | Failed: ${phase.failed}\n\n`;
            });
            
            // Add test details sections for each phase
            phases.forEach(phase => {
              summary += `<details>\n<summary>${phase.phase} - Output Details</summary>\n\n`;
              summary += '```\n';
              // Get last 30 lines of output for each phase
              const lines = phase.output.split('\n');
              const lastLines = lines.slice(-30).join('\n');
              summary += lastLines;
              summary += '\n```\n</details>\n\n';
            });
            
            // Comment on PR
            try {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: summary
              });
              console.log('Successfully posted test results to PR');
            } catch (error) {
              console.error('Failed to post comment:', error);
              // Don't fail the workflow if commenting fails
            }