name: Scenario Tests

on:
  pull_request:
    paths:
      - 'tests/scenarios/**'
      - 'controlplane/**'
      - '.github/workflows/scenario-tests.yml'
  workflow_dispatch:

permissions:
  contents: read
  pull-requests: write
  checks: write

jobs:
  test-phases:
    runs-on: [self-hosted, aws-testable, large]
    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: tests/scenarios/go.mod

      - name: Download dependencies
        run: |
          cd tests/scenarios
          go mod download
          go mod tidy

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build KECS Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./controlplane
          file: ./controlplane/Dockerfile.test
          tags: kecs:test
          load: true
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Run Phase 1 tests (Cluster Operations)
        id: test-phase1
        run: |
          cd tests/scenarios
          echo "## Running Phase 1: Cluster Operations tests ##"
          ginkgo -v -timeout 30m \
            --no-color \
            --junit-report=junit-phase1.xml \
            --output-dir=. \
            ./phase1/... | tee test-output-phase1.log
          
          # Capture exit code
          echo "exit_code=$?" >> $GITHUB_OUTPUT
        env:
          KECS_LOG_LEVEL: info

      - name: Run Phase 2 tests (Task Definitions and Services)
        id: test-phase2
        run: |
          cd tests/scenarios
          echo "## Running Phase 2: Task Definitions and Services tests ##"
          ginkgo -v -timeout 30m \
            --no-color \
            --junit-report=junit-phase2.xml \
            --output-dir=. \
            ./phase2/... | tee test-output-phase2.log
          
          # Capture exit code
          echo "exit_code=$?" >> $GITHUB_OUTPUT
        env:
          KECS_LOG_LEVEL: info

      # Phase 3-4 tests are not yet implemented

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: |
            tests/scenarios/junit-phase1.xml
            tests/scenarios/test-output-phase1.log
            tests/scenarios/junit-phase2.xml
            tests/scenarios/test-output-phase2.log

      - name: Test Report - Phase 1
        uses: dorny/test-reporter@v1
        if: always() && github.event_name == 'pull_request'
        with:
          name: Phase 1 - Cluster Operations Tests
          path: tests/scenarios/junit-phase1.xml
          reporter: java-junit
          fail-on-error: false
          fail-on-empty: false

      - name: Test Report - Phase 2
        uses: dorny/test-reporter@v1
        if: always() && github.event_name == 'pull_request'
        with:
          name: Phase 2 - Task Definitions and Services Tests
          path: tests/scenarios/junit-phase2.xml
          reporter: java-junit
          fail-on-error: false
          fail-on-empty: false

      # Phase 3-4 test reports are not yet implemented

      - name: Comment PR with test results
        uses: actions/github-script@v7
        if: always() && github.event_name == 'pull_request'
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');
            
            // Function to parse test timing from Ginkgo output
            function parseTestTiming(output) {
              const tests = [];
              // Match pattern: Context and test description followed by timing
              // Example:
              // Cluster CreateCluster 
              //   should successfully create a new cluster
              //   /path/to/file:line
              // • [15.123 seconds]
              const testPattern = /([^\n]+)\n\s+([^\n]+)\n\s+[^\n]+\n• (?:\[SLOW TEST\] )?\[(\d+\.?\d*) seconds?\]/gm;
              let match;
              
              while ((match = testPattern.exec(output)) !== null) {
                const context = match[1].trim();
                const description = match[2].trim();
                const fullName = `${context} ${description}`;
                
                tests.push({
                  duration: parseFloat(match[3]),
                  name: fullName
                });
              }
              
              return tests;
            }
            
            // Calculate phase statistics
            function calculatePhaseStats(tests) {
              if (tests.length === 0) return null;
              
              const totalDuration = tests.reduce((sum, test) => sum + test.duration, 0);
              const avgDuration = totalDuration / tests.length;
              const slowestTests = tests
                .sort((a, b) => b.duration - a.duration)
                .slice(0, 3);
              
              return {
                totalDuration,
                avgDuration,
                slowestTests,
                testCount: tests.length
              };
            }
            
            // Function to parse test output
            function parseTestOutput(filename, phaseName) {
              let testOutput = '';
              try {
                testOutput = fs.readFileSync(filename, 'utf8');
                // Remove ANSI escape codes for cleaner output
                testOutput = testOutput.replace(/\x1b\[[0-9;]*m/g, '');
              } catch (e) {
                return null;
              }
              
              // Remove ANSI color codes before parsing
              const cleanOutput = testOutput.replace(/\x1b\[[0-9;]*m/g, '');
              
              const summaryMatch = cleanOutput.match(/Ran (\d+) of (\d+) Specs in ([\d.]+)\s*(?:seconds?|s)/);
              // Fallback: Try to get total specs from "Will run X of Y specs"
              const willRunMatch = cleanOutput.match(/Will run (\d+) of (\d+) specs/);
              
              // Look for the summary line pattern: "X Passed | Y Failed | Z Pending | W Skipped"
              const summaryLine = cleanOutput.match(/(\d+) Passed.*?(\d+) Failed.*?(\d+) Pending.*?(\d+) Skipped/);
              
              let passedMatch, failedMatch, pendingMatch, skippedMatch;
              if (summaryLine) {
                passedMatch = [summaryLine[0], summaryLine[1]];
                failedMatch = [summaryLine[0], summaryLine[2]];
                pendingMatch = [summaryLine[0], summaryLine[3]];
                skippedMatch = [summaryLine[0], summaryLine[4]];
              } else {
                // Fallback to individual matches
                passedMatch = cleanOutput.match(/(\d+) Passed/);
                failedMatch = cleanOutput.match(/(\d+) Failed/);
                pendingMatch = cleanOutput.match(/(\d+) Pending/);
                skippedMatch = cleanOutput.match(/(\d+) Skipped/);
              }
              
              // Parse individual test timings
              const testTimings = parseTestTiming(cleanOutput);
              const phaseStats = calculatePhaseStats(testTimings);
              
              // Calculate total and ran values
              let total = 0, ran = 0;
              if (summaryMatch) {
                ran = parseInt(summaryMatch[1]);
                total = parseInt(summaryMatch[2]);
              } else if (willRunMatch) {
                // If we couldn't parse the summary but have "Will run", use that for total
                total = parseInt(willRunMatch[2]);
                // For ran, sum up all the results
                ran = (passedMatch ? parseInt(passedMatch[1]) : 0) + 
                      (failedMatch ? parseInt(failedMatch[1]) : 0) + 
                      (pendingMatch ? parseInt(pendingMatch[1]) : 0) + 
                      (skippedMatch ? parseInt(skippedMatch[1]) : 0);
              }
              
              const result = {
                phase: phaseName,
                total: total,
                ran: ran,
                passed: passedMatch ? parseInt(passedMatch[1]) : 0,
                failed: failedMatch ? parseInt(failedMatch[1]) : 0,
                pending: pendingMatch ? parseInt(pendingMatch[1]) : 0,
                skipped: skippedMatch ? parseInt(skippedMatch[1]) : 0,
                totalDuration: summaryMatch ? parseFloat(summaryMatch[3]) : null,
                testTimings: testTimings,
                stats: phaseStats,
                output: testOutput
              };
              
              // Debug logging
              console.log(`Parsed ${phaseName}:`);
              console.log(`  summaryMatch: ${summaryMatch}`);
              console.log(`  passedMatch: ${passedMatch}`);
              console.log(`  failedMatch: ${failedMatch}`);
              console.log(`  testTimings found: ${testTimings.length}`);
              console.log(`  Result:`, result);
              
              return result;
            }
            
            // Parse outputs from phase 1 and phase 2
            const phase1 = parseTestOutput('tests/scenarios/test-output-phase1.log', 'Phase 1: Cluster Operations');
            const phase2 = parseTestOutput('tests/scenarios/test-output-phase2.log', 'Phase 2: Task Definitions and Services');
            
            // Combine results
            const phases = [phase1, phase2].filter(p => p !== null);
            
            let summary = '## 🧪 Scenario Test Results\n\n';
            
            // Overall summary
            let totalPassed = 0, totalFailed = 0, totalRan = 0, totalSpecs = 0, totalDuration = 0;
            phases.forEach(phase => {
              totalPassed += phase.passed;
              totalFailed += phase.failed;
              totalRan += phase.ran;
              totalSpecs += phase.total;
              if (phase.totalDuration) {
                totalDuration += phase.totalDuration;
              }
            });
            
            // Format duration
            function formatDuration(seconds) {
              if (seconds < 60) {
                return `${seconds.toFixed(1)}s`;
              }
              const minutes = Math.floor(seconds / 60);
              const secs = (seconds % 60).toFixed(0);
              return `${minutes}m ${secs}s`;
            }
            
            summary += `### Overall Summary\n`;
            summary += `- Total Specs: ${totalSpecs}\n`;
            summary += `- Total Ran: ${totalRan}\n`;
            summary += `- ✅ Total Passed: ${totalPassed}\n`;
            summary += `- ❌ Total Failed: ${totalFailed}\n`;
            if (totalDuration > 0) {
              summary += `- ⏱️ Total Duration: ${formatDuration(totalDuration)}\n`;
            }
            summary += '\n';
            
            if (totalFailed === 0 && totalRan > 0) {
              summary += '### ✅ All tests passed!\n\n';
            } else if (totalFailed > 0) {
              summary += '### ❌ Some tests failed\n\n';
            }
            
            // Phase-by-phase breakdown
            summary += '### Phase Results\n\n';
            phases.forEach(phase => {
              const status = phase.failed === 0 ? '✅' : '❌';
              const durationStr = phase.totalDuration ? ` (${formatDuration(phase.totalDuration)})` : '';
              summary += `**${phase.phase}** ${status}${durationStr}\n`;
              summary += `- Specs: ${phase.total} | Ran: ${phase.ran} | Passed: ${phase.passed} | Failed: ${phase.failed}\n\n`;
            });
            
            // Performance Analysis
            const allTests = [];
            phases.forEach(phase => {
              if (phase.testTimings && phase.testTimings.length > 0) {
                phase.testTimings.forEach(test => {
                  allTests.push({
                    ...test,
                    phase: phase.phase
                  });
                });
              }
            });
            
            if (allTests.length > 0) {
              summary += '### ⚡ Performance Analysis\n\n';
              
              // Slowest tests
              const slowestTests = allTests
                .sort((a, b) => b.duration - a.duration)
                .slice(0, 5);
              
              if (slowestTests.length > 0) {
                summary += '**Slowest Tests:**\n';
                slowestTests.forEach((test, index) => {
                  let icon = '🚀';
                  if (test.duration > 30) icon = '🐌';
                  else if (test.duration > 10) icon = '🐢';
                  
                  summary += `${index + 1}. ${icon} ${test.name} (${test.duration.toFixed(1)}s) - ${test.phase}\n`;
                });
                summary += '\n';
              }
              
              // Phase timing breakdown
              summary += '**Phase Timing Breakdown:**\n';
              summary += '| Phase | Duration | Tests | Avg Time/Test |\n';
              summary += '|-------|----------|-------|---------------|\n';
              
              phases.forEach(phase => {
                if (phase.stats && phase.stats.testCount > 0) {
                  const avgTime = phase.stats.avgDuration.toFixed(2);
                  const duration = formatDuration(phase.totalDuration || phase.stats.totalDuration);
                  summary += `| ${phase.phase} | ${duration} | ${phase.stats.testCount} | ${avgTime}s |\n`;
                }
              });
              summary += '\n';
              
              // Detailed test results table
              summary += '### 📊 Detailed Test Results\n\n';
              summary += '<details>\n<summary>Click to expand all test results</summary>\n\n';
              
              phases.forEach(phase => {
                if (phase.testTimings && phase.testTimings.length > 0) {
                  summary += `\n#### ${phase.phase}\n\n`;
                  summary += '| Test Name | Duration | Status |\n';
                  summary += '|-----------|----------|--------|\n';
                  
                  // Sort tests by duration (slowest first)
                  const sortedTests = [...phase.testTimings].sort((a, b) => b.duration - a.duration);
                  
                  sortedTests.forEach(test => {
                    let durationIcon = '🚀';
                    if (test.duration > 30) durationIcon = '🐌';
                    else if (test.duration > 10) durationIcon = '🐢';
                    else if (test.duration > 5) durationIcon = '⚡';
                    
                    // Truncate long test names
                    const testName = test.name.length > 80 
                      ? test.name.substring(0, 77) + '...' 
                      : test.name;
                    
                    summary += `| ${testName} | ${durationIcon} ${test.duration.toFixed(2)}s | ✅ |\n`;
                  });
                }
              });
              
              summary += '\n</details>\n\n';
            }
            
            // Add test details sections for each phase
            phases.forEach(phase => {
              summary += `<details>\n<summary>${phase.phase} - Output Details</summary>\n\n`;
              summary += '```\n';
              // Get last 30 lines of output for each phase
              const lines = phase.output.split('\n');
              const lastLines = lines.slice(-30).join('\n');
              summary += lastLines;
              summary += '\n```\n</details>\n\n';
            });
            
            // Comment on PR
            try {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: summary
              });
              console.log('Successfully posted test results to PR');
            } catch (error) {
              console.error('Failed to post comment:', error);
              // Don't fail the workflow if commenting fails
            }