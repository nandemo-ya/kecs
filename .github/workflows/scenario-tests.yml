name: Scenario Tests

on:
  pull_request:
    paths:
      - 'tests/scenarios/**'
      - 'controlplane/**'
      - '.github/workflows/scenario-tests.yml'
  workflow_dispatch:

permissions:
  contents: read
  pull-requests: write
  checks: write

jobs:
  test-phases:
    runs-on: [self-hosted, aws-testable, large]
    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: tests/scenarios/go.mod

      - name: Download dependencies
        run: |
          cd tests/scenarios
          go mod download
          go mod tidy

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build KECS Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./controlplane
          file: ./controlplane/Dockerfile.test
          tags: kecs:test
          load: true
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Run Phase 1 tests (Cluster Operations)
        id: test-phase1
        run: |
          cd tests/scenarios
          echo "## Running Phase 1: Cluster Operations tests ##"
          ginkgo -v -timeout 30m \
            --no-color \
            --junit-report=junit-phase1.xml \
            --output-dir=. \
            ./phase1/... | tee test-output-phase1.log
          
          # Capture exit code
          echo "exit_code=$?" >> $GITHUB_OUTPUT
        env:
          KECS_LOG_LEVEL: info

      - name: Run Phase 2 tests (Task Definitions and Services)
        id: test-phase2
        run: |
          cd tests/scenarios
          echo "## Running Phase 2: Task Definitions and Services tests ##"
          ginkgo -v -timeout 30m \
            --no-color \
            --junit-report=junit-phase2.xml \
            --output-dir=. \
            ./phase2/... | tee test-output-phase2.log
          
          # Capture exit code
          echo "exit_code=$?" >> $GITHUB_OUTPUT
        env:
          KECS_LOG_LEVEL: info

      # Phase 3-4 tests are not yet implemented

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: |
            tests/scenarios/junit-phase1.xml
            tests/scenarios/test-output-phase1.log
            tests/scenarios/junit-phase2.xml
            tests/scenarios/test-output-phase2.log

      - name: Test Report - Phase 1
        uses: dorny/test-reporter@v1
        if: always() && github.event_name == 'pull_request'
        with:
          name: Phase 1 - Cluster Operations Tests
          path: tests/scenarios/junit-phase1.xml
          reporter: java-junit
          fail-on-error: false
          fail-on-empty: false

      - name: Test Report - Phase 2
        uses: dorny/test-reporter@v1
        if: always() && github.event_name == 'pull_request'
        with:
          name: Phase 2 - Task Definitions and Services Tests
          path: tests/scenarios/junit-phase2.xml
          reporter: java-junit
          fail-on-error: false
          fail-on-empty: false

      # Phase 3-4 test reports are not yet implemented

      - name: Comment PR with test results
        uses: actions/github-script@v7
        if: always() && github.event_name == 'pull_request'
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');
            
            // Function to parse test output
            function parseTestOutput(filename, phaseName) {
              let testOutput = '';
              try {
                testOutput = fs.readFileSync(filename, 'utf8');
                // Remove ANSI escape codes for cleaner output
                testOutput = testOutput.replace(/\x1b\[[0-9;]*m/g, '');
              } catch (e) {
                return null;
              }
              
              // Remove ANSI color codes before parsing
              const cleanOutput = testOutput.replace(/\x1b\[[0-9;]*m/g, '');
              
              const summaryMatch = cleanOutput.match(/Ran (\d+) of (\d+) Specs in .*/);
              // Look for the summary line pattern: "X Passed | Y Failed | Z Pending | W Skipped"
              const summaryLine = cleanOutput.match(/(\d+) Passed.*?(\d+) Failed.*?(\d+) Pending.*?(\d+) Skipped/);
              
              let passedMatch, failedMatch, pendingMatch, skippedMatch;
              if (summaryLine) {
                passedMatch = [summaryLine[0], summaryLine[1]];
                failedMatch = [summaryLine[0], summaryLine[2]];
                pendingMatch = [summaryLine[0], summaryLine[3]];
                skippedMatch = [summaryLine[0], summaryLine[4]];
              } else {
                // Fallback to individual matches
                passedMatch = cleanOutput.match(/(\d+) Passed/);
                failedMatch = cleanOutput.match(/(\d+) Failed/);
                pendingMatch = cleanOutput.match(/(\d+) Pending/);
                skippedMatch = cleanOutput.match(/(\d+) Skipped/);
              }
              
              const result = {
                phase: phaseName,
                total: summaryMatch ? parseInt(summaryMatch[2]) : 0,
                ran: summaryMatch ? parseInt(summaryMatch[1]) : 0,
                passed: passedMatch ? parseInt(passedMatch[1]) : 0,
                failed: failedMatch ? parseInt(failedMatch[1]) : 0,
                pending: pendingMatch ? parseInt(pendingMatch[1]) : 0,
                skipped: skippedMatch ? parseInt(skippedMatch[1]) : 0,
                output: testOutput
              };
              
              // Debug logging
              console.log(`Parsed ${phaseName}:`);
              console.log(`  summaryMatch: ${summaryMatch}`);
              console.log(`  passedMatch: ${passedMatch}`);
              console.log(`  failedMatch: ${failedMatch}`);
              console.log(`  Result:`, result);
              
              return result;
            }
            
            // Parse outputs from phase 1 and phase 2
            const phase1 = parseTestOutput('tests/scenarios/test-output-phase1.log', 'Phase 1: Cluster Operations');
            const phase2 = parseTestOutput('tests/scenarios/test-output-phase2.log', 'Phase 2: Task Definitions and Services');
            
            // Combine results
            const phases = [phase1, phase2].filter(p => p !== null);
            
            let summary = '## 🧪 Scenario Test Results\n\n';
            
            // Overall summary
            let totalPassed = 0, totalFailed = 0, totalRan = 0, totalSpecs = 0;
            phases.forEach(phase => {
              totalPassed += phase.passed;
              totalFailed += phase.failed;
              totalRan += phase.ran;
              totalSpecs += phase.total;
            });
            
            summary += `### Overall Summary\n`;
            summary += `- Total Specs: ${totalSpecs}\n`;
            summary += `- Total Ran: ${totalRan}\n`;
            summary += `- ✅ Total Passed: ${totalPassed}\n`;
            summary += `- ❌ Total Failed: ${totalFailed}\n\n`;
            
            if (totalFailed === 0 && totalRan > 0) {
              summary += '### ✅ All tests passed!\n\n';
            } else if (totalFailed > 0) {
              summary += '### ❌ Some tests failed\n\n';
            }
            
            // Phase-by-phase breakdown
            summary += '### Phase Results\n\n';
            phases.forEach(phase => {
              const status = phase.failed === 0 ? '✅' : '❌';
              summary += `**${phase.phase}** ${status}\n`;
              summary += `- Specs: ${phase.total} | Ran: ${phase.ran} | Passed: ${phase.passed} | Failed: ${phase.failed}\n\n`;
            });
            
            // Add test details sections for each phase
            phases.forEach(phase => {
              summary += `<details>\n<summary>${phase.phase} - Output Details</summary>\n\n`;
              summary += '```\n';
              // Get last 30 lines of output for each phase
              const lines = phase.output.split('\n');
              const lastLines = lines.slice(-30).join('\n');
              summary += lastLines;
              summary += '\n```\n</details>\n\n';
            });
            
            // Comment on PR
            try {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: summary
              });
              console.log('Successfully posted test results to PR');
            } catch (error) {
              console.error('Failed to post comment:', error);
              // Don't fail the workflow if commenting fails
            }