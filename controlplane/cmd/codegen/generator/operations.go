package generator

import (
	"fmt"
	"sort"
	"text/template"

	"github.com/nandemo-ya/kecs/controlplane/cmd/codegen/parser"
)

// OperationInfo holds information about an API operation
type OperationInfo struct {
	Name       string
	InputType  string
	OutputType string
	Errors     []string
	HTTPMethod string
	HTTPPath   string
}

// generateOperationsFile generates the operations.go file
func (g *Generator) generateOperationsFile(api *parser.SmithyAPI) error {
	tmpl := template.Must(template.New("operations").Parse(operationsTemplate))

	// Get service info
	serviceShape, serviceName, err := api.GetServiceShape()
	if err != nil {
		return fmt.Errorf("failed to get service shape: %w", err)
	}

	// Collect all operations
	operations := g.collectOperations(api, serviceShape)
	
	// Sort operations for consistent output
	var opNames []string
	for name := range operations {
		opNames = append(opNames, name)
	}
	sort.Strings(opNames)

	// Generate content
	data := struct {
		Package      string
		Service      string
		ServiceName  string
		Operations   map[string]*OperationInfo
		OperationNames []string
	}{
		Package:      g.packageName,
		Service:      g.service,
		ServiceName:  parser.GetShapeName(serviceName),
		Operations:   operations,
		OperationNames: opNames,
	}

	content, err := g.executeTemplate(tmpl, data)
	if err != nil {
		return err
	}

	return g.writeFormattedFile("operations.go", content)
}

// collectOperations collects all operations from the service
func (g *Generator) collectOperations(api *parser.SmithyAPI, serviceShape *parser.SmithyShape) map[string]*OperationInfo {
	operations := make(map[string]*OperationInfo)
	
	for _, opRef := range serviceShape.Operations {
		opName := parser.GetShapeName(opRef.Target)
		opShape, exists := api.Shapes[opRef.Target]
		if !exists || opShape.Type != "operation" {
			continue
		}
		
		opInfo := &OperationInfo{
			Name: opName,
		}
		
		// Get input type
		if opShape.Input != nil {
			inputName := parser.GetShapeName(opShape.Input.Target)
			opInfo.InputType = inputName
		}
		
		// Get output type
		if opShape.Output != nil {
			outputName := parser.GetShapeName(opShape.Output.Target)
			opInfo.OutputType = outputName
		}
		
		// Get error types
		for _, errRef := range opShape.Errors {
			errName := parser.GetShapeName(errRef.Target)
			opInfo.Errors = append(opInfo.Errors, errName)
		}
		
		// Get HTTP info from traits
		if opShape.Traits != nil {
			if httpTrait, ok := opShape.Traits["smithy.api#http"]; ok {
				if httpInfo, ok := httpTrait.(map[string]interface{}); ok {
					if method, ok := httpInfo["method"].(string); ok {
						opInfo.HTTPMethod = method
					}
					if uri, ok := httpInfo["uri"].(string); ok {
						opInfo.HTTPPath = uri
					}
				}
			}
		}
		
		operations[opName] = opInfo
	}
	
	return operations
}

const operationsTemplate = `// Code generated by cmd/codegen. DO NOT EDIT.

package {{.Package}}

import (
	"context"
)

// ECSAPIInterface defines the interface for {{.Service}} operations
type ECSAPIInterface interface {
{{range $name := .OperationNames}}
{{$op := index $.Operations $name}}
	// {{$op.Name}} performs the {{$op.Name}} operation
	{{$op.Name}}(ctx context.Context, input *{{$op.InputType}}) (*{{$op.OutputType}}, error)
{{end}}
}

// {{.ServiceName}}API is an alias for ECSAPIInterface for backward compatibility
type {{.ServiceName}}API = ECSAPIInterface

// Operation names
const (
{{range $name := .OperationNames}}
	Operation{{$name}} = "{{$name}}"
{{end}}
)

// Error types
var (
{{range $name := .OperationNames}}
{{$op := index $.Operations $name}}
{{range $err := $op.Errors}}
	// {{$err}} is returned by {{$op.Name}}
	_ = &{{$err}}{}
{{end}}
{{end}}
)
`