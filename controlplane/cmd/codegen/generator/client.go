package generator

import (
	"fmt"
	"sort"
	"text/template"

	"github.com/nandemo-ya/kecs/controlplane/cmd/codegen/parser"
)

// generateClientFile generates the client.go file
func (g *Generator) generateClientFile(api *parser.SmithyAPI) error {
	tmpl := template.Must(template.New("client").Parse(clientTemplate))

	// Get service info
	serviceShape, serviceName, err := api.GetServiceShape()
	if err != nil {
		return fmt.Errorf("failed to get service shape: %w", err)
	}

	// Collect all operations
	operations := g.collectOperations(api, serviceShape)

	// Sort operations for consistent output
	var opNames []string
	for name := range operations {
		opNames = append(opNames, name)
	}
	sort.Strings(opNames)

	// Get service metadata
	var serviceVersion string
	if serviceShape.Traits != nil {
		if versionTrait, ok := serviceShape.Traits["aws.protocols#awsJson1_1"]; ok {
			if versionInfo, ok := versionTrait.(map[string]interface{}); ok {
				if v, ok := versionInfo["version"].(string); ok {
					serviceVersion = v
				}
			}
		}
	}

	// Generate content
	data := struct {
		Package        string
		Service        string
		ServiceName    string
		ServiceVersion string
		Operations     map[string]*OperationInfo
		OperationNames []string
	}{
		Package:        g.packageName,
		Service:        g.service,
		ServiceName:    parser.GetShapeName(serviceName),
		ServiceVersion: serviceVersion,
		Operations:     operations,
		OperationNames: opNames,
	}

	content, err := g.executeTemplate(tmpl, data)
	if err != nil {
		return err
	}

	return g.writeFormattedFile("client.go", content)
}

const clientTemplate = `// Code generated by cmd/codegen. DO NOT EDIT.

package {{.Package}}

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"time"
)

// Client is an HTTP client for {{.Service}} API
type Client struct {
	endpoint   string
	httpClient *http.Client
	service    string
	version    string
}

// ClientOptions contains options for creating a client
type ClientOptions struct {
	// Endpoint is the API endpoint URL
	Endpoint string
	
	// HTTPClient is the HTTP client to use
	HTTPClient *http.Client
	
	// Timeout is the request timeout
	Timeout time.Duration
}

// NewClient creates a new {{.Service}} API client
func NewClient(opts ClientOptions) *Client {
	if opts.HTTPClient == nil {
		opts.HTTPClient = &http.Client{
			Timeout: opts.Timeout,
		}
		if opts.Timeout == 0 {
			opts.HTTPClient.Timeout = 30 * time.Second
		}
	}

	return &Client{
		endpoint:   opts.Endpoint,
		httpClient: opts.HTTPClient,
		service:    "{{.ServiceName}}",
		version:    "{{.ServiceVersion}}",
	}
}

{{range $name := .OperationNames}}
{{$op := index $.Operations $name}}
// {{$op.Name}} performs the {{$op.Name}} operation
func (c *Client) {{$op.Name}}(ctx context.Context, input *{{$op.InputType}}) (*{{$op.OutputType}}, error) {
	output := &{{$op.OutputType}}{}
	err := c.doRequest(ctx, "{{$op.Name}}", input, output)
	return output, err
}

{{end}}

// doRequest performs an HTTP request
func (c *Client) doRequest(ctx context.Context, operation string, input, output interface{}) error {
	// Marshal input
	var body io.Reader
	if input != nil {
		data, err := json.Marshal(input)
		if err != nil {
			return fmt.Errorf("failed to marshal request: %w", err)
		}
		body = bytes.NewReader(data)
	}

	// Create request
	req, err := http.NewRequestWithContext(ctx, "POST", c.endpoint+"/v1/"+operation, body)
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	req.Header.Set("Content-Type", "application/x-amz-json-1.1")
	req.Header.Set("X-Amz-Target", c.service+"."+operation)

	// Send request
	resp, err := c.httpClient.Do(req)
	if err != nil {
		return fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	// Read response
	respData, err := io.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("failed to read response: %w", err)
	}

	// Handle errors
	if resp.StatusCode >= 400 {
		var errResp struct {
			Type    string ` + "`" + `json:"__type"` + "`" + `
			Message string ` + "`" + `json:"message"` + "`" + `
		}
		if err := json.Unmarshal(respData, &errResp); err == nil {
			return fmt.Errorf("%s: %s", errResp.Type, errResp.Message)
		}
		return fmt.Errorf("request failed with status %d: %s", resp.StatusCode, string(respData))
	}

	// Unmarshal response
	if output != nil && len(respData) > 0 {
		if err := json.Unmarshal(respData, output); err != nil {
			return fmt.Errorf("failed to unmarshal response: %w", err)
		}
	}

	return nil
}
`
