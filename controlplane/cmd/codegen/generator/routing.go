package generator

import (
	"fmt"
	"sort"
	"text/template"

	"github.com/nandemo-ya/kecs/controlplane/cmd/codegen/parser"
)

// generateRoutingFile generates the routing.go file
func (g *Generator) generateRoutingFile(api *parser.SmithyAPI) error {
	tmpl := template.Must(template.New("routing").Parse(routingTemplate))

	// Get service info
	serviceShape, serviceName, err := api.GetServiceShape()
	if err != nil {
		return fmt.Errorf("failed to get service shape: %w", err)
	}

	// Collect all operations
	operations := g.collectOperations(api, serviceShape)
	
	// Sort operations for consistent output
	var opNames []string
	for name := range operations {
		opNames = append(opNames, name)
	}
	sort.Strings(opNames)

	// Generate content
	data := struct {
		Package        string
		Service        string
		ServiceName    string
		Operations     map[string]*OperationInfo
		OperationNames []string
	}{
		Package:        g.packageName,
		Service:        g.service,
		ServiceName:    parser.GetShapeName(serviceName),
		Operations:     operations,
		OperationNames: opNames,
	}

	content, err := g.executeTemplate(tmpl, data)
	if err != nil {
		return err
	}

	return g.writeFormattedFile("routing.go", content)
}

const routingTemplate = `// Code generated by cmd/codegen. DO NOT EDIT.

package {{.Package}}

import (
	"encoding/json"
	"fmt"
	"net/http"
	"strings"
)

// Router handles HTTP routing for {{.Service}} API
type Router struct {
	api {{.ServiceName}}API
}

// NewRouter creates a new router for {{.Service}} API
func NewRouter(api {{.ServiceName}}API) *Router {
	return &Router{api: api}
}

// Route routes an HTTP request to the appropriate handler
func (r *Router) Route(w http.ResponseWriter, req *http.Request) {
	// Extract action from request
	action := r.extractAction(req)
	if action == "" {
		writeError(w, http.StatusBadRequest, "MissingAction", "Could not determine action from request")
		return
	}

	// Route to appropriate handler
	switch action {
{{range $name := .OperationNames}}
	case "{{$name}}":
		r.handle{{$name}}(w, req)
{{end}}
	default:
		writeError(w, http.StatusBadRequest, "InvalidAction", fmt.Sprintf("Unknown action: %s", action))
	}
}

// extractAction extracts the action from the request
func (r *Router) extractAction(req *http.Request) string {
	// Check X-Amz-Target header
	if target := req.Header.Get("X-Amz-Target"); target != "" {
		parts := strings.Split(target, ".")
		if len(parts) > 1 {
			return parts[1]
		}
	}

	// Check URL path
	if strings.HasPrefix(req.URL.Path, "/v1/") {
		parts := strings.Split(strings.TrimPrefix(req.URL.Path, "/v1/"), "/")
		if len(parts) > 0 {
			return parts[0]
		}
	}

	// Check query parameter
	return req.URL.Query().Get("Action")
}

{{range $name := .OperationNames}}
{{$op := index $.Operations $name}}
// handle{{$op.Name}} handles the {{$op.Name}} operation
func (r *Router) handle{{$op.Name}}(w http.ResponseWriter, req *http.Request) {
	// Parse input
	var input {{$op.InputType}}
	if req.ContentLength > 0 {
		if err := json.NewDecoder(req.Body).Decode(&input); err != nil {
			writeError(w, http.StatusBadRequest, "InvalidParameterValue", fmt.Sprintf("Invalid JSON: %v", err))
			return
		}
	}

	// Call API
	output, err := r.api.{{$op.Name}}(req.Context(), &input)
	if err != nil {
		writeAPIError(w, err)
		return
	}

	// Write response
	writeJSON(w, http.StatusOK, output)
}

{{end}}

// writeJSON writes a JSON response
func writeJSON(w http.ResponseWriter, statusCode int, data interface{}) {
	w.Header().Set("Content-Type", "application/x-amz-json-1.1")
	w.WriteHeader(statusCode)
	
	if data != nil {
		encoder := json.NewEncoder(w)
		encoder.SetEscapeHTML(false)
		_ = encoder.Encode(data)
	}
}

// writeError writes an error response
func writeError(w http.ResponseWriter, statusCode int, code, message string) {
	w.Header().Set("Content-Type", "application/x-amz-json-1.1")
	w.WriteHeader(statusCode)
	
	_ = json.NewEncoder(w).Encode(map[string]interface{}{
		"__type": code,
		"message": message,
	})
}

// writeAPIError writes an API error response
func writeAPIError(w http.ResponseWriter, err error) {
	// TODO: Handle specific error types
	writeError(w, http.StatusInternalServerError, "InternalError", err.Error())
}
`