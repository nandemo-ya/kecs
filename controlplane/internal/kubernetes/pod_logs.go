package kubernetes

import (
	"bufio"
	"context"
	"fmt"
	"io"
	"strings"
	"time"

	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes"

	"github.com/nandemo-ya/kecs/controlplane/internal/logging"
	"github.com/nandemo-ya/kecs/controlplane/internal/storage"
)

// PodLogService provides log retrieval from Kubernetes pods
type PodLogService struct {
	kubeClient kubernetes.Interface
}

// NewPodLogService creates a new pod log service
func NewPodLogService(kubeClient kubernetes.Interface) *PodLogService {
	return &PodLogService{
		kubeClient: kubeClient,
	}
}

// GetLogs retrieves logs from a pod container
func (s *PodLogService) GetLogs(ctx context.Context, namespace, podName, containerName string, options *LogOptions) ([]storage.TaskLog, error) {
	podLogOptions := &corev1.PodLogOptions{
		Container:  containerName,
		Timestamps: true,
	}

	if options != nil {
		if options.Follow {
			podLogOptions.Follow = true
		}
		if options.TailLines > 0 {
			tailLines := int64(options.TailLines)
			podLogOptions.TailLines = &tailLines
		}
		if options.SinceTime != nil {
			podLogOptions.SinceTime = &metav1.Time{Time: *options.SinceTime}
		}
		if options.Previous {
			podLogOptions.Previous = true
		}
	}

	req := s.kubeClient.CoreV1().Pods(namespace).GetLogs(podName, podLogOptions)
	stream, err := req.Stream(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get log stream: %w", err)
	}
	defer stream.Close()

	var logs []storage.TaskLog
	scanner := bufio.NewScanner(stream)

	for scanner.Scan() {
		line := scanner.Text()
		timestamp, logLine := parseLogLine(line)

		log := storage.TaskLog{
			// ID will be generated by storage
			TaskArn:       fmt.Sprintf("arn:aws:ecs:%s:%s:task/%s/%s", "us-east-1", "000000000000", namespace, podName),
			ContainerName: containerName,
			Timestamp:     timestamp,
			LogLine:       logLine,
			LogLevel:      extractLogLevel(logLine),
			CreatedAt:     time.Now(),
		}

		logs = append(logs, log)
	}

	if err := scanner.Err(); err != nil {
		return nil, fmt.Errorf("error reading log stream: %w", err)
	}

	return logs, nil
}

// StreamLogs streams logs from a pod container through a channel
func (s *PodLogService) StreamLogs(ctx context.Context, namespace, podName, containerName string, options *LogOptions) (<-chan storage.TaskLog, <-chan error, error) {
	podLogOptions := &corev1.PodLogOptions{
		Container:  containerName,
		Follow:     true,
		Timestamps: true,
	}

	if options != nil {
		if options.TailLines > 0 {
			tailLines := int64(options.TailLines)
			podLogOptions.TailLines = &tailLines
		}
		if options.SinceTime != nil {
			podLogOptions.SinceTime = &metav1.Time{Time: *options.SinceTime}
		}
		if options.Previous {
			podLogOptions.Previous = true
		}
	}

	req := s.kubeClient.CoreV1().Pods(namespace).GetLogs(podName, podLogOptions)
	stream, err := req.Stream(ctx)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to get log stream: %w", err)
	}

	logChan := make(chan storage.TaskLog, 100)
	errChan := make(chan error, 1)

	go func() {
		defer close(logChan)
		defer close(errChan)
		defer stream.Close()

		reader := bufio.NewReader(stream)
		for {
			select {
			case <-ctx.Done():
				return
			default:
				line, err := reader.ReadString('\n')
				if err != nil {
					if err != io.EOF {
						errChan <- fmt.Errorf("error reading log stream: %w", err)
					}
					return
				}

				line = strings.TrimSuffix(line, "\n")
				timestamp, logLine := parseLogLine(line)

				log := storage.TaskLog{
					TaskArn:       fmt.Sprintf("arn:aws:ecs:%s:%s:task/%s/%s", "us-east-1", "000000000000", namespace, podName),
					ContainerName: containerName,
					Timestamp:     timestamp,
					LogLine:       logLine,
					LogLevel:      extractLogLevel(logLine),
					CreatedAt:     time.Now(),
				}

				select {
				case logChan <- log:
				case <-ctx.Done():
					return
				}
			}
		}
	}()

	return logChan, errChan, nil
}

// CollectLogsForTerminatedPod collects all logs from a terminated pod
func (s *PodLogService) CollectLogsForTerminatedPod(ctx context.Context, namespace, podName string) (map[string][]storage.TaskLog, error) {
	// Get pod to find all containers
	pod, err := s.kubeClient.CoreV1().Pods(namespace).Get(ctx, podName, metav1.GetOptions{})
	if err != nil {
		return nil, fmt.Errorf("failed to get pod: %w", err)
	}

	allLogs := make(map[string][]storage.TaskLog)

	// Collect logs from all containers
	for _, container := range pod.Spec.Containers {
		options := &LogOptions{
			Previous: true, // Get logs from previous container run if pod restarted
		}

		logs, err := s.GetLogs(ctx, namespace, podName, container.Name, options)
		if err != nil {
			// Log the error but continue with other containers
			logging.Warn("Failed to get logs for container",
				"pod", podName,
				"container", container.Name,
				"error", err,
			)
			continue
		}

		allLogs[container.Name] = logs
	}

	// Also collect logs from init containers
	for _, container := range pod.Spec.InitContainers {
		options := &LogOptions{
			Previous: false, // Init containers run once
		}

		logs, err := s.GetLogs(ctx, namespace, podName, container.Name, options)
		if err != nil {
			logging.Warn("Failed to get logs for init container",
				"pod", podName,
				"container", container.Name,
				"error", err,
			)
			continue
		}

		allLogs[container.Name] = logs
	}

	return allLogs, nil
}

// LogOptions configures log retrieval
type LogOptions struct {
	// Follow the log stream
	Follow bool

	// Number of lines to tail
	TailLines int

	// Return logs since this time
	SinceTime *time.Time

	// Return logs from previous container instance
	Previous bool
}

// parseLogLine parses a log line with timestamp prefix
// Format: "2024-01-20T10:30:45.123456789Z Log message here"
func parseLogLine(line string) (time.Time, string) {
	parts := strings.SplitN(line, " ", 2)
	if len(parts) < 2 {
		return time.Now(), line
	}

	timestamp, err := time.Parse(time.RFC3339Nano, parts[0])
	if err != nil {
		// If parsing fails, use current time
		return time.Now(), line
	}

	return timestamp, parts[1]
}

// extractLogLevel attempts to extract log level from log line
func extractLogLevel(logLine string) string {
	upperLine := strings.ToUpper(logLine)

	// Common log level patterns
	patterns := []struct {
		pattern string
		level   string
	}{
		{"[ERROR]", "ERROR"},
		{"ERROR:", "ERROR"},
		{"[WARN]", "WARN"},
		{"WARN:", "WARN"},
		{"[WARNING]", "WARN"},
		{"WARNING:", "WARN"},
		{"[INFO]", "INFO"},
		{"INFO:", "INFO"},
		{"[DEBUG]", "DEBUG"},
		{"DEBUG:", "DEBUG"},
		{"[TRACE]", "TRACE"},
		{"TRACE:", "TRACE"},
		{"[FATAL]", "FATAL"},
		{"FATAL:", "FATAL"},
	}

	for _, p := range patterns {
		if strings.Contains(upperLine, p.pattern) {
			return p.level
		}
	}

	// Check for common error indicators
	if strings.Contains(upperLine, "ERROR") || strings.Contains(upperLine, "EXCEPTION") {
		return "ERROR"
	}
	if strings.Contains(upperLine, "WARN") {
		return "WARN"
	}

	return ""
}
