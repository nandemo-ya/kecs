// Code generated by cmd/codegen. DO NOT EDIT.

package generated

import (
	"context"
	"net/http"
)

// ECSServiceInterface defines the interface for all ECS operations
type ECSServiceInterface interface {
	CreateCapacityProvider(ctx context.Context, req *CreateCapacityProviderRequest) (*CreateCapacityProviderResponse, error)
	CreateCluster(ctx context.Context, req *CreateClusterRequest) (*CreateClusterResponse, error)
	CreateService(ctx context.Context, req *CreateServiceRequest) (*CreateServiceResponse, error)
	CreateTaskSet(ctx context.Context, req *CreateTaskSetRequest) (*CreateTaskSetResponse, error)
	DeleteAccountSetting(ctx context.Context, req *DeleteAccountSettingRequest) (*DeleteAccountSettingResponse, error)
	DeleteAttributes(ctx context.Context, req *DeleteAttributesRequest) (*DeleteAttributesResponse, error)
	DeleteCapacityProvider(ctx context.Context, req *DeleteCapacityProviderRequest) (*DeleteCapacityProviderResponse, error)
	DeleteCluster(ctx context.Context, req *DeleteClusterRequest) (*DeleteClusterResponse, error)
	DeleteService(ctx context.Context, req *DeleteServiceRequest) (*DeleteServiceResponse, error)
	DeleteTaskDefinitions(ctx context.Context, req *DeleteTaskDefinitionsRequest) (*DeleteTaskDefinitionsResponse, error)
	DeleteTaskSet(ctx context.Context, req *DeleteTaskSetRequest) (*DeleteTaskSetResponse, error)
	DeregisterContainerInstance(ctx context.Context, req *DeregisterContainerInstanceRequest) (*DeregisterContainerInstanceResponse, error)
	DeregisterTaskDefinition(ctx context.Context, req *DeregisterTaskDefinitionRequest) (*DeregisterTaskDefinitionResponse, error)
	DescribeCapacityProviders(ctx context.Context, req *DescribeCapacityProvidersRequest) (*DescribeCapacityProvidersResponse, error)
	DescribeClusters(ctx context.Context, req *DescribeClustersRequest) (*DescribeClustersResponse, error)
	DescribeContainerInstances(ctx context.Context, req *DescribeContainerInstancesRequest) (*DescribeContainerInstancesResponse, error)
	DescribeServiceDeployments(ctx context.Context, req *DescribeServiceDeploymentsRequest) (*DescribeServiceDeploymentsResponse, error)
	DescribeServiceRevisions(ctx context.Context, req *DescribeServiceRevisionsRequest) (*DescribeServiceRevisionsResponse, error)
	DescribeServices(ctx context.Context, req *DescribeServicesRequest) (*DescribeServicesResponse, error)
	DescribeTaskDefinition(ctx context.Context, req *DescribeTaskDefinitionRequest) (*DescribeTaskDefinitionResponse, error)
	DescribeTaskSets(ctx context.Context, req *DescribeTaskSetsRequest) (*DescribeTaskSetsResponse, error)
	DescribeTasks(ctx context.Context, req *DescribeTasksRequest) (*DescribeTasksResponse, error)
	DiscoverPollEndpoint(ctx context.Context, req *DiscoverPollEndpointRequest) (*DiscoverPollEndpointResponse, error)
	ExecuteCommand(ctx context.Context, req *ExecuteCommandRequest) (*ExecuteCommandResponse, error)
	GetTaskProtection(ctx context.Context, req *GetTaskProtectionRequest) (*GetTaskProtectionResponse, error)
	ListAccountSettings(ctx context.Context, req *ListAccountSettingsRequest) (*ListAccountSettingsResponse, error)
	ListAttributes(ctx context.Context, req *ListAttributesRequest) (*ListAttributesResponse, error)
	ListClusters(ctx context.Context, req *ListClustersRequest) (*ListClustersResponse, error)
	ListContainerInstances(ctx context.Context, req *ListContainerInstancesRequest) (*ListContainerInstancesResponse, error)
	ListServiceDeployments(ctx context.Context, req *ListServiceDeploymentsRequest) (*ListServiceDeploymentsResponse, error)
	ListServices(ctx context.Context, req *ListServicesRequest) (*ListServicesResponse, error)
	ListServicesByNamespace(ctx context.Context, req *ListServicesByNamespaceRequest) (*ListServicesByNamespaceResponse, error)
	ListTagsForResource(ctx context.Context, req *ListTagsForResourceRequest) (*ListTagsForResourceResponse, error)
	ListTaskDefinitionFamilies(ctx context.Context, req *ListTaskDefinitionFamiliesRequest) (*ListTaskDefinitionFamiliesResponse, error)
	ListTaskDefinitions(ctx context.Context, req *ListTaskDefinitionsRequest) (*ListTaskDefinitionsResponse, error)
	ListTasks(ctx context.Context, req *ListTasksRequest) (*ListTasksResponse, error)
	PutAccountSetting(ctx context.Context, req *PutAccountSettingRequest) (*PutAccountSettingResponse, error)
	PutAccountSettingDefault(ctx context.Context, req *PutAccountSettingDefaultRequest) (*PutAccountSettingDefaultResponse, error)
	PutAttributes(ctx context.Context, req *PutAttributesRequest) (*PutAttributesResponse, error)
	PutClusterCapacityProviders(ctx context.Context, req *PutClusterCapacityProvidersRequest) (*PutClusterCapacityProvidersResponse, error)
	RegisterContainerInstance(ctx context.Context, req *RegisterContainerInstanceRequest) (*RegisterContainerInstanceResponse, error)
	RegisterTaskDefinition(ctx context.Context, req *RegisterTaskDefinitionRequest) (*RegisterTaskDefinitionResponse, error)
	RunTask(ctx context.Context, req *RunTaskRequest) (*RunTaskResponse, error)
	StartTask(ctx context.Context, req *StartTaskRequest) (*StartTaskResponse, error)
	StopServiceDeployment(ctx context.Context, req *StopServiceDeploymentRequest) (*StopServiceDeploymentResponse, error)
	StopTask(ctx context.Context, req *StopTaskRequest) (*StopTaskResponse, error)
	SubmitAttachmentStateChanges(ctx context.Context, req *SubmitAttachmentStateChangesRequest) (*SubmitAttachmentStateChangesResponse, error)
	SubmitContainerStateChange(ctx context.Context, req *SubmitContainerStateChangeRequest) (*SubmitContainerStateChangeResponse, error)
	SubmitTaskStateChange(ctx context.Context, req *SubmitTaskStateChangeRequest) (*SubmitTaskStateChangeResponse, error)
	TagResource(ctx context.Context, req *TagResourceRequest) (*TagResourceResponse, error)
	UntagResource(ctx context.Context, req *UntagResourceRequest) (*UntagResourceResponse, error)
	UpdateCapacityProvider(ctx context.Context, req *UpdateCapacityProviderRequest) (*UpdateCapacityProviderResponse, error)
	UpdateCluster(ctx context.Context, req *UpdateClusterRequest) (*UpdateClusterResponse, error)
	UpdateClusterSettings(ctx context.Context, req *UpdateClusterSettingsRequest) (*UpdateClusterSettingsResponse, error)
	UpdateContainerAgent(ctx context.Context, req *UpdateContainerAgentRequest) (*UpdateContainerAgentResponse, error)
	UpdateContainerInstancesState(ctx context.Context, req *UpdateContainerInstancesStateRequest) (*UpdateContainerInstancesStateResponse, error)
	UpdateService(ctx context.Context, req *UpdateServiceRequest) (*UpdateServiceResponse, error)
	UpdateServicePrimaryTaskSet(ctx context.Context, req *UpdateServicePrimaryTaskSetRequest) (*UpdateServicePrimaryTaskSetResponse, error)
	UpdateTaskProtection(ctx context.Context, req *UpdateTaskProtectionRequest) (*UpdateTaskProtectionResponse, error)
	UpdateTaskSet(ctx context.Context, req *UpdateTaskSetRequest) (*UpdateTaskSetResponse, error)
}

// ECSService implements the ECS service operations
type ECSService struct{}

// NewECSService creates a new ECS service instance
func NewECSService() *ECSService {
	return &ECSService{}
}

// CreateCapacityProvider <p>Creates a new capacity provider. Capacity providers are associated with an Amazon ECS
			cluster and are used in capacity provider strategies to facilitate cluster auto
			scaling.</p>
         <p>Only capacity providers that use an Auto Scaling group can be created. Amazon ECS tasks on
			Fargate use the <code>FARGATE</code> and <code>FARGATE_SPOT</code> capacity providers.
			These providers are available to all accounts in the Amazon Web Services Regions that Fargate
			supports.</p>
func (s *ECSService) CreateCapacityProvider(ctx context.Context, req *CreateCapacityProviderRequest) (*CreateCapacityProviderResponse, error) {
	// TODO: Implement CreateCapacityProvider operation
	return &CreateCapacityProviderResponse{}, nil
}

// CreateCluster <p>Creates a new Amazon ECS cluster. By default, your account receives a <code>default</code>
			cluster when you launch your first container instance. However, you can create your own
			cluster with a unique name.</p>
         <note>
            <p>When you call the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_CreateCluster.html">CreateCluster</a>
				API operation, Amazon ECS attempts to create the Amazon ECS service-linked role for your
				account. This is so that it can manage required resources in other Amazon Web Services services on
				your behalf. However, if the user that makes the call doesn't have permissions to
				create the service-linked role, it isn't created. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/using-service-linked-roles.html">Using
					service-linked roles for Amazon ECS</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
         </note>
func (s *ECSService) CreateCluster(ctx context.Context, req *CreateClusterRequest) (*CreateClusterResponse, error) {
	// TODO: Implement CreateCluster operation
	return &CreateClusterResponse{}, nil
}

// CreateService <p>Runs and maintains your desired number of tasks from a specified task definition. If
			the number of tasks running in a service drops below the <code>desiredCount</code>,
			Amazon ECS runs another copy of the task in the specified cluster. To update an existing
			service, use <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_UpdateService.html">UpdateService</a>.</p>
         <note>
            <p>On March 21, 2024, a change was made to resolve the task definition revision before authorization. When a task definition revision is not specified, authorization will occur using the latest revision of a task definition.</p>
         </note>
         <note>
            <p>Amazon Elastic Inference (EI) is no longer available to customers.</p>
         </note>
         <p>In addition to maintaining the desired count of tasks in your service, you can
			optionally run your service behind one or more load balancers. The load balancers
			distribute traffic across the tasks that are associated with the service. For more
			information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-load-balancing.html">Service load balancing</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
         <p>You can attach Amazon EBS volumes to Amazon ECS tasks by configuring the volume when creating or
			updating a service. <code>volumeConfigurations</code> is only supported for REPLICA
			service and not DAEMON service. For more infomation, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ebs-volumes.html#ebs-volume-types">Amazon EBS volumes</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
         <p>Tasks for services that don't use a load balancer are considered healthy if they're in
			the <code>RUNNING</code> state. Tasks for services that use a load balancer are
			considered healthy if they're in the <code>RUNNING</code> state and are reported as
			healthy by the load balancer.</p>
         <p>There are two service scheduler strategies available:</p>
         <ul>
            <li>
               <p>
                  <code>REPLICA</code> - The replica scheduling strategy places and
					maintains your desired number of tasks across your cluster. By default, the
					service scheduler spreads tasks across Availability Zones. You can use task
					placement strategies and constraints to customize task placement decisions. For
					more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs_services.html">Service scheduler concepts</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
            </li>
            <li>
               <p>
                  <code>DAEMON</code> - The daemon scheduling strategy deploys exactly one
					task on each active container instance that meets all of the task placement
					constraints that you specify in your cluster. The service scheduler also
					evaluates the task placement constraints for running tasks. It also stops tasks
					that don't meet the placement constraints. When using this strategy, you don't
					need to specify a desired number of tasks, a task placement strategy, or use
					Service Auto Scaling policies. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs_services.html">Service scheduler concepts</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
            </li>
         </ul>
         <p>You can optionally specify a deployment configuration for your service. The deployment
			is initiated by changing properties. For example, the deployment might be initiated by
			the task definition or by your desired count of a service. You can use <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_UpdateService.html">UpdateService</a>. The default value for a replica service for
				<code>minimumHealthyPercent</code> is 100%. The default value for a daemon service
			for <code>minimumHealthyPercent</code> is 0%.</p>
         <p>If a service uses the <code>ECS</code> deployment controller, the minimum healthy
			percent represents a lower limit on the number of tasks in a service that must remain in
			the <code>RUNNING</code> state during a deployment. Specifically, it represents it as a
			percentage of your desired number of tasks (rounded up to the nearest integer). This
			happens when any of your container instances are in the <code>DRAINING</code> state if
			the service contains tasks using the EC2 launch type. Using this
			parameter, you can deploy without using additional cluster capacity. For example, if you
			set your service to have desired number of four tasks and a minimum healthy percent of
			50%, the scheduler might stop two existing tasks to free up cluster capacity before
			starting two new tasks. If they're in the <code>RUNNING</code> state, tasks for services
			that don't use a load balancer are considered healthy . If they're in the
				<code>RUNNING</code> state and reported as healthy by the load balancer, tasks for
			services that <i>do</i> use a load balancer are considered healthy . The
			default value for minimum healthy percent is 100%.</p>
         <p>If a service uses the <code>ECS</code> deployment controller, the <b>maximum percent</b> parameter represents an upper limit on the
			number of tasks in a service that are allowed in the <code>RUNNING</code> or
				<code>PENDING</code> state during a deployment. Specifically, it represents it as a
			percentage of the desired number of tasks (rounded down to the nearest integer). This
			happens when any of your container instances are in the <code>DRAINING</code> state if
			the service contains tasks using the EC2 launch type. Using this
			parameter, you can define the deployment batch size. For example, if your service has a
			desired number of four tasks and a maximum percent value of 200%, the scheduler may
			start four new tasks before stopping the four older tasks (provided that the cluster
			resources required to do this are available). The default value for maximum percent is
			200%.</p>
         <p>If a service uses either the <code>CODE_DEPLOY</code> or <code>EXTERNAL</code>
			deployment controller types and tasks that use the EC2 launch type, the
				<b>minimum healthy percent</b> and <b>maximum percent</b> values are used only to define the lower and upper limit
			on the number of the tasks in the service that remain in the <code>RUNNING</code> state.
			This is while the container instances are in the <code>DRAINING</code> state. If the
			tasks in the service use the Fargate launch type, the minimum healthy
			percent and maximum percent values aren't used. This is the case even if they're
			currently visible when describing your service.</p>
         <p>When creating a service that uses the <code>EXTERNAL</code> deployment controller, you
			can specify only parameters that aren't controlled at the task set level. The only
			required parameter is the service name. You control your services using the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_CreateTaskSet.html">CreateTaskSet</a>. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html">Amazon ECS deployment types</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
         <p>When the service scheduler launches new tasks, it determines task placement. For
			information about task placement and task placement strategies, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-placement.html">Amazon ECS
				task placement</a> in the <i>Amazon Elastic Container Service Developer Guide</i>
         </p>
func (s *ECSService) CreateService(ctx context.Context, req *CreateServiceRequest) (*CreateServiceResponse, error) {
	// TODO: Implement CreateService operation
	return &CreateServiceResponse{}, nil
}

// CreateTaskSet <p>Create a task set in the specified cluster and service. This is used when a service
			uses the <code>EXTERNAL</code> deployment controller type. For more information, see
				<a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html">Amazon ECS deployment
				types</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
         <note>
            <p>On March 21, 2024, a change was made to resolve the task definition revision before authorization. When a task definition revision is not specified, authorization will occur using the latest revision of a task definition.</p>
         </note>
         <p>For information about the maximum number of task sets and other quotas, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-quotas.html">Amazon ECS
				service quotas</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
func (s *ECSService) CreateTaskSet(ctx context.Context, req *CreateTaskSetRequest) (*CreateTaskSetResponse, error) {
	// TODO: Implement CreateTaskSet operation
	return &CreateTaskSetResponse{}, nil
}

// DeleteAccountSetting <p>Disables an account setting for a specified user, role, or the root user for an
			account.</p>
func (s *ECSService) DeleteAccountSetting(ctx context.Context, req *DeleteAccountSettingRequest) (*DeleteAccountSettingResponse, error) {
	// TODO: Implement DeleteAccountSetting operation
	return &DeleteAccountSettingResponse{}, nil
}

// DeleteAttributes <p>Deletes one or more custom attributes from an Amazon ECS resource.</p>
func (s *ECSService) DeleteAttributes(ctx context.Context, req *DeleteAttributesRequest) (*DeleteAttributesResponse, error) {
	// TODO: Implement DeleteAttributes operation
	return &DeleteAttributesResponse{}, nil
}

// DeleteCapacityProvider <p>Deletes the specified capacity provider.</p>
         <note>
            <p>The <code>FARGATE</code> and <code>FARGATE_SPOT</code> capacity providers are
				reserved and can't be deleted. You can disassociate them from a cluster using either
					<a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_PutClusterCapacityProviders.html">PutClusterCapacityProviders</a> or by deleting the cluster.</p>
         </note>
         <p>Prior to a capacity provider being deleted, the capacity provider must be removed from
			the capacity provider strategy from all services. The <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_UpdateService.html">UpdateService</a> API
			can be used to remove a capacity provider from a service's capacity provider strategy.
			When updating a service, the <code>forceNewDeployment</code> option can be used to
			ensure that any tasks using the Amazon EC2 instance capacity provided by the capacity
			provider are transitioned to use the capacity from the remaining capacity providers.
			Only capacity providers that aren't associated with a cluster can be deleted. To remove
			a capacity provider from a cluster, you can either use <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_PutClusterCapacityProviders.html">PutClusterCapacityProviders</a> or delete the cluster.</p>
func (s *ECSService) DeleteCapacityProvider(ctx context.Context, req *DeleteCapacityProviderRequest) (*DeleteCapacityProviderResponse, error) {
	// TODO: Implement DeleteCapacityProvider operation
	return &DeleteCapacityProviderResponse{}, nil
}

// DeleteCluster <p>Deletes the specified cluster. The cluster transitions to the <code>INACTIVE</code>
			state. Clusters with an <code>INACTIVE</code> status might remain discoverable in your
			account for a period of time. However, this behavior is subject to change in the future.
			We don't recommend that you rely on <code>INACTIVE</code> clusters persisting.</p>
         <p>You must deregister all container instances from this cluster before you may delete
			it. You can list the container instances in a cluster with <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ListContainerInstances.html">ListContainerInstances</a> and deregister them with <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_DeregisterContainerInstance.html">DeregisterContainerInstance</a>.</p>
func (s *ECSService) DeleteCluster(ctx context.Context, req *DeleteClusterRequest) (*DeleteClusterResponse, error) {
	// TODO: Implement DeleteCluster operation
	return &DeleteClusterResponse{}, nil
}

// DeleteService <p>Deletes a specified service within a cluster. You can delete a service if you have no
			running tasks in it and the desired task count is zero. If the service is actively
			maintaining tasks, you can't delete it, and you must update the service to a desired
			task count of zero. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_UpdateService.html">UpdateService</a>.</p>
         <note>
            <p>When you delete a service, if there are still running tasks that require cleanup,
				the service status moves from <code>ACTIVE</code> to <code>DRAINING</code>, and the
				service is no longer visible in the console or in the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ListServices.html">ListServices</a>
				API operation. After all tasks have transitioned to either <code>STOPPING</code> or
					<code>STOPPED</code> status, the service status moves from <code>DRAINING</code>
				to <code>INACTIVE</code>. Services in the <code>DRAINING</code> or
					<code>INACTIVE</code> status can still be viewed with the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_DescribeServices.html">DescribeServices</a> API operation. However, in the future,
					<code>INACTIVE</code> services may be cleaned up and purged from Amazon ECS record
				keeping, and <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_DescribeServices.html">DescribeServices</a> calls on those services return a
					<code>ServiceNotFoundException</code> error.</p>
         </note>
         <important>
            <p>If you attempt to create a new service with the same name as an existing service
				in either <code>ACTIVE</code> or <code>DRAINING</code> status, you receive an
				error.</p>
         </important>
func (s *ECSService) DeleteService(ctx context.Context, req *DeleteServiceRequest) (*DeleteServiceResponse, error) {
	// TODO: Implement DeleteService operation
	return &DeleteServiceResponse{}, nil
}

// DeleteTaskDefinitions <p>Deletes one or more task definitions.</p>
         <p>You must deregister a task definition revision before you delete it. For more
			information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_DeregisterTaskDefinition.html">DeregisterTaskDefinition</a>.</p>
         <p>When you delete a task definition revision, it is immediately transitions from the
				<code>INACTIVE</code> to <code>DELETE_IN_PROGRESS</code>. Existing tasks and
			services that reference a <code>DELETE_IN_PROGRESS</code> task definition revision
			continue to run without disruption. Existing services that reference a
				<code>DELETE_IN_PROGRESS</code> task definition revision can still scale up or down
			by modifying the service's desired count.</p>
         <p>You can't use a <code>DELETE_IN_PROGRESS</code> task definition revision to run new
			tasks or create new services. You also can't update an existing service to reference a
				<code>DELETE_IN_PROGRESS</code> task definition revision.</p>
         <p> A task definition revision will stay in <code>DELETE_IN_PROGRESS</code> status until
			all the associated tasks and services have been terminated.</p>
         <p>When you delete all <code>INACTIVE</code> task definition revisions, the task
			definition name is not displayed in the console and not returned in the API. If a task
			definition revisions are in the <code>DELETE_IN_PROGRESS</code> state, the task
			definition name is displayed in the console and returned in the API. The task definition
			name is retained by Amazon ECS and the revision is incremented the next time you create a
			task definition with that name.</p>
func (s *ECSService) DeleteTaskDefinitions(ctx context.Context, req *DeleteTaskDefinitionsRequest) (*DeleteTaskDefinitionsResponse, error) {
	// TODO: Implement DeleteTaskDefinitions operation
	return &DeleteTaskDefinitionsResponse{}, nil
}

// DeleteTaskSet <p>Deletes a specified task set within a service. This is used when a service uses the
				<code>EXTERNAL</code> deployment controller type. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html">Amazon ECS deployment types</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
func (s *ECSService) DeleteTaskSet(ctx context.Context, req *DeleteTaskSetRequest) (*DeleteTaskSetResponse, error) {
	// TODO: Implement DeleteTaskSet operation
	return &DeleteTaskSetResponse{}, nil
}

// DeregisterContainerInstance <p>Deregisters an Amazon ECS container instance from the specified cluster. This instance is
			no longer available to run tasks.</p>
         <p>If you intend to use the container instance for some other purpose after
			deregistration, we recommend that you stop all of the tasks running on the container
			instance before deregistration. That prevents any orphaned tasks from consuming
			resources.</p>
         <p>Deregistering a container instance removes the instance from a cluster, but it doesn't
			terminate the EC2 instance. If you are finished using the instance, be sure to terminate
			it in the Amazon EC2 console to stop billing.</p>
         <note>
            <p>If you terminate a running container instance, Amazon ECS automatically deregisters the
				instance from your cluster (stopped container instances or instances with
				disconnected agents aren't automatically deregistered when terminated).</p>
         </note>
func (s *ECSService) DeregisterContainerInstance(ctx context.Context, req *DeregisterContainerInstanceRequest) (*DeregisterContainerInstanceResponse, error) {
	// TODO: Implement DeregisterContainerInstance operation
	return &DeregisterContainerInstanceResponse{}, nil
}

// DeregisterTaskDefinition <p>Deregisters the specified task definition by family and revision. Upon deregistration,
			the task definition is marked as <code>INACTIVE</code>. Existing tasks and services that
			reference an <code>INACTIVE</code> task definition continue to run without disruption.
			Existing services that reference an <code>INACTIVE</code> task definition can still
			scale up or down by modifying the service's desired count. If you want to delete a task
			definition revision, you must first deregister the task definition revision.</p>
         <p>You can't use an <code>INACTIVE</code> task definition to run new tasks or create new
			services, and you can't update an existing service to reference an <code>INACTIVE</code>
			task definition. However, there may be up to a 10-minute window following deregistration
			where these restrictions have not yet taken effect.</p>
         <note>
            <p>At this time, <code>INACTIVE</code> task definitions remain discoverable in your
				account indefinitely. However, this behavior is subject to change in the future. We
				don't recommend that you rely on <code>INACTIVE</code> task definitions persisting
				beyond the lifecycle of any associated tasks and services.</p>
         </note>
         <p>You must deregister a task definition revision before you delete it. For more
			information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_DeleteTaskDefinitions.html">DeleteTaskDefinitions</a>.</p>
func (s *ECSService) DeregisterTaskDefinition(ctx context.Context, req *DeregisterTaskDefinitionRequest) (*DeregisterTaskDefinitionResponse, error) {
	// TODO: Implement DeregisterTaskDefinition operation
	return &DeregisterTaskDefinitionResponse{}, nil
}

// DescribeCapacityProviders <p>Describes one or more of your capacity providers.</p>
func (s *ECSService) DescribeCapacityProviders(ctx context.Context, req *DescribeCapacityProvidersRequest) (*DescribeCapacityProvidersResponse, error) {
	// TODO: Implement DescribeCapacityProviders operation
	return &DescribeCapacityProvidersResponse{}, nil
}

// DescribeClusters <p>Describes one or more of your clusters.</p>
         <p> For CLI examples, see <a href="https://github.com/aws/aws-cli/blob/develop/awscli/examples/ecs/describe-clusters.rst">describe-clusters.rst</a> on GitHub.</p>
func (s *ECSService) DescribeClusters(ctx context.Context, req *DescribeClustersRequest) (*DescribeClustersResponse, error) {
	// TODO: Implement DescribeClusters operation
	return &DescribeClustersResponse{}, nil
}

// DescribeContainerInstances <p>Describes one or more container instances. Returns metadata about each container
			instance requested.</p>
func (s *ECSService) DescribeContainerInstances(ctx context.Context, req *DescribeContainerInstancesRequest) (*DescribeContainerInstancesResponse, error) {
	// TODO: Implement DescribeContainerInstances operation
	return &DescribeContainerInstancesResponse{}, nil
}

// DescribeServiceDeployments <p>Describes one or more of your service deployments.</p>
         <p>A service deployment happens when you release a software update for the service. For
			more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-deployment.html">View service history using Amazon ECS service deployments</a>.</p>
func (s *ECSService) DescribeServiceDeployments(ctx context.Context, req *DescribeServiceDeploymentsRequest) (*DescribeServiceDeploymentsResponse, error) {
	// TODO: Implement DescribeServiceDeployments operation
	return &DescribeServiceDeploymentsResponse{}, nil
}

// DescribeServiceRevisions <p>Describes one or more service revisions.</p>
         <p>A service revision is a version of the service that includes the values for the Amazon
			ECS resources (for example, task definition) and the environment resources (for example,
			load balancers, subnets, and security groups). For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-revision.html">Amazon ECS service revisions</a>.</p>
         <p>You can't describe a service revision that was created before October 25, 2024.</p>
func (s *ECSService) DescribeServiceRevisions(ctx context.Context, req *DescribeServiceRevisionsRequest) (*DescribeServiceRevisionsResponse, error) {
	// TODO: Implement DescribeServiceRevisions operation
	return &DescribeServiceRevisionsResponse{}, nil
}

// DescribeServices <p>Describes the specified services running in your cluster.</p>
func (s *ECSService) DescribeServices(ctx context.Context, req *DescribeServicesRequest) (*DescribeServicesResponse, error) {
	// TODO: Implement DescribeServices operation
	return &DescribeServicesResponse{}, nil
}

// DescribeTaskDefinition <p>Describes a task definition. You can specify a <code>family</code> and
				<code>revision</code> to find information about a specific task definition, or you
			can simply specify the family to find the latest <code>ACTIVE</code> revision in that
			family.</p>
         <note>
            <p>You can only describe <code>INACTIVE</code> task definitions while an active task
				or service references them.</p>
         </note>
func (s *ECSService) DescribeTaskDefinition(ctx context.Context, req *DescribeTaskDefinitionRequest) (*DescribeTaskDefinitionResponse, error) {
	// TODO: Implement DescribeTaskDefinition operation
	return &DescribeTaskDefinitionResponse{}, nil
}

// DescribeTaskSets <p>Describes the task sets in the specified cluster and service. This is used when a
			service uses the <code>EXTERNAL</code> deployment controller type. For more information,
			see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html">Amazon ECS Deployment
				Types</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
func (s *ECSService) DescribeTaskSets(ctx context.Context, req *DescribeTaskSetsRequest) (*DescribeTaskSetsResponse, error) {
	// TODO: Implement DescribeTaskSets operation
	return &DescribeTaskSetsResponse{}, nil
}

// DescribeTasks <p>Describes a specified task or tasks.</p>
         <p>Currently, stopped tasks appear in the returned results for at least one hour.</p>
         <p>If you have tasks with tags, and then delete the cluster, the tagged tasks are
			returned in the response. If you create a new cluster with the same name as the deleted
			cluster, the tagged tasks are not included in the response.</p>
func (s *ECSService) DescribeTasks(ctx context.Context, req *DescribeTasksRequest) (*DescribeTasksResponse, error) {
	// TODO: Implement DescribeTasks operation
	return &DescribeTasksResponse{}, nil
}

// DiscoverPollEndpoint <note>
            <p>This action is only used by the Amazon ECS agent, and it is not intended for use outside of the agent.</p>
         </note>
         <p>Returns an endpoint for the Amazon ECS agent to poll for updates.</p>
func (s *ECSService) DiscoverPollEndpoint(ctx context.Context, req *DiscoverPollEndpointRequest) (*DiscoverPollEndpointResponse, error) {
	// TODO: Implement DiscoverPollEndpoint operation
	return &DiscoverPollEndpointResponse{}, nil
}

// ExecuteCommand <p>Runs a command remotely on a container within a task.</p>
         <p>If you use a condition key in your IAM policy to refine the conditions for the
			policy statement, for example limit the actions to a specific cluster, you receive an
				<code>AccessDeniedException</code> when there is a mismatch between the condition
			key value and the corresponding parameter value.</p>
         <p>For information about required permissions and considerations, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-exec.html">Using Amazon ECS
				Exec for debugging</a> in the <i>Amazon ECS Developer Guide</i>.
		</p>
func (s *ECSService) ExecuteCommand(ctx context.Context, req *ExecuteCommandRequest) (*ExecuteCommandResponse, error) {
	// TODO: Implement ExecuteCommand operation
	return &ExecuteCommandResponse{}, nil
}

// GetTaskProtection <p>Retrieves the protection status of tasks in an Amazon ECS service.</p>
func (s *ECSService) GetTaskProtection(ctx context.Context, req *GetTaskProtectionRequest) (*GetTaskProtectionResponse, error) {
	// TODO: Implement GetTaskProtection operation
	return &GetTaskProtectionResponse{}, nil
}

// ListAccountSettings <p>Lists the account settings for a specified principal.</p>
func (s *ECSService) ListAccountSettings(ctx context.Context, req *ListAccountSettingsRequest) (*ListAccountSettingsResponse, error) {
	// TODO: Implement ListAccountSettings operation
	return &ListAccountSettingsResponse{}, nil
}

// ListAttributes <p>Lists the attributes for Amazon ECS resources within a specified target type and cluster.
			When you specify a target type and cluster, <code>ListAttributes</code> returns a list
			of attribute objects, one for each attribute on each resource. You can filter the list
			of results to a single attribute name to only return results that have that name. You
			can also filter the results by attribute name and value. You can do this, for example,
			to see which container instances in a cluster are running a Linux AMI
				(<code>ecs.os-type=linux</code>). </p>
func (s *ECSService) ListAttributes(ctx context.Context, req *ListAttributesRequest) (*ListAttributesResponse, error) {
	// TODO: Implement ListAttributes operation
	return &ListAttributesResponse{}, nil
}

// ListClusters <p>Returns a list of existing clusters.</p>
func (s *ECSService) ListClusters(ctx context.Context, req *ListClustersRequest) (*ListClustersResponse, error) {
	// TODO: Implement ListClusters operation
	return &ListClustersResponse{}, nil
}

// ListContainerInstances <p>Returns a list of container instances in a specified cluster. You can filter the
			results of a <code>ListContainerInstances</code> operation with cluster query language
			statements inside the <code>filter</code> parameter. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/cluster-query-language.html">Cluster Query Language</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
func (s *ECSService) ListContainerInstances(ctx context.Context, req *ListContainerInstancesRequest) (*ListContainerInstancesResponse, error) {
	// TODO: Implement ListContainerInstances operation
	return &ListContainerInstancesResponse{}, nil
}

// ListServiceDeployments <p>This operation lists all the service deployments that meet the specified filter
			criteria.</p>
         <p>A service deployment happens when you release a software update for the service. You
			route traffic from the running service revisions to the new service revison and control
			the number of running tasks. </p>
         <p>This API returns the values that you use for the request parameters in <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_DescribeServiceRevisions.html">DescribeServiceRevisions</a>.</p>
func (s *ECSService) ListServiceDeployments(ctx context.Context, req *ListServiceDeploymentsRequest) (*ListServiceDeploymentsResponse, error) {
	// TODO: Implement ListServiceDeployments operation
	return &ListServiceDeploymentsResponse{}, nil
}

// ListServices <p>Returns a list of services. You can filter the results by cluster, launch type, and
			scheduling strategy.</p>
func (s *ECSService) ListServices(ctx context.Context, req *ListServicesRequest) (*ListServicesResponse, error) {
	// TODO: Implement ListServices operation
	return &ListServicesResponse{}, nil
}

// ListServicesByNamespace <p>This operation lists all of the services that are associated with a Cloud Map
			namespace. This list might include services in different clusters. In contrast,
				<code>ListServices</code> can only list services in one cluster at a time. If you
			need to filter the list of services in a single cluster by various parameters, use
				<code>ListServices</code>. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-connect.html">Service Connect</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
func (s *ECSService) ListServicesByNamespace(ctx context.Context, req *ListServicesByNamespaceRequest) (*ListServicesByNamespaceResponse, error) {
	// TODO: Implement ListServicesByNamespace operation
	return &ListServicesByNamespaceResponse{}, nil
}

// ListTagsForResource <p>List the tags for an Amazon ECS resource.</p>
func (s *ECSService) ListTagsForResource(ctx context.Context, req *ListTagsForResourceRequest) (*ListTagsForResourceResponse, error) {
	// TODO: Implement ListTagsForResource operation
	return &ListTagsForResourceResponse{}, nil
}

// ListTaskDefinitionFamilies <p>Returns a list of task definition families that are registered to your account. This
			list includes task definition families that no longer have any <code>ACTIVE</code> task
			definition revisions.</p>
         <p>You can filter out task definition families that don't contain any <code>ACTIVE</code>
			task definition revisions by setting the <code>status</code> parameter to
				<code>ACTIVE</code>. You can also filter the results with the
				<code>familyPrefix</code> parameter.</p>
func (s *ECSService) ListTaskDefinitionFamilies(ctx context.Context, req *ListTaskDefinitionFamiliesRequest) (*ListTaskDefinitionFamiliesResponse, error) {
	// TODO: Implement ListTaskDefinitionFamilies operation
	return &ListTaskDefinitionFamiliesResponse{}, nil
}

// ListTaskDefinitions <p>Returns a list of task definitions that are registered to your account. You can filter
			the results by family name with the <code>familyPrefix</code> parameter or by status
			with the <code>status</code> parameter.</p>
func (s *ECSService) ListTaskDefinitions(ctx context.Context, req *ListTaskDefinitionsRequest) (*ListTaskDefinitionsResponse, error) {
	// TODO: Implement ListTaskDefinitions operation
	return &ListTaskDefinitionsResponse{}, nil
}

// ListTasks <p>Returns a list of tasks. You can filter the results by cluster, task definition
			family, container instance, launch type, what IAM principal started the task, or by
			the desired status of the task.</p>
         <p>Recently stopped tasks might appear in the returned results. </p>
func (s *ECSService) ListTasks(ctx context.Context, req *ListTasksRequest) (*ListTasksResponse, error) {
	// TODO: Implement ListTasks operation
	return &ListTasksResponse{}, nil
}

// PutAccountSetting <p>Modifies an account setting. Account settings are set on a per-Region basis.</p>
         <p>If you change the root user account setting, the default settings are reset for users and
			roles that do not have specified individual account settings. For more information, see
				<a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-account-settings.html">Account
				Settings</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
func (s *ECSService) PutAccountSetting(ctx context.Context, req *PutAccountSettingRequest) (*PutAccountSettingResponse, error) {
	// TODO: Implement PutAccountSetting operation
	return &PutAccountSettingResponse{}, nil
}

// PutAccountSettingDefault <p>Modifies an account setting for all users on an account for whom no individual account
			setting has been specified. Account settings are set on a per-Region basis.</p>
func (s *ECSService) PutAccountSettingDefault(ctx context.Context, req *PutAccountSettingDefaultRequest) (*PutAccountSettingDefaultResponse, error) {
	// TODO: Implement PutAccountSettingDefault operation
	return &PutAccountSettingDefaultResponse{}, nil
}

// PutAttributes <p>Create or update an attribute on an Amazon ECS resource. If the attribute doesn't exist,
			it's created. If the attribute exists, its value is replaced with the specified value.
			To delete an attribute, use <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_DeleteAttributes.html">DeleteAttributes</a>. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-placement-constraints.html#attributes">Attributes</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
func (s *ECSService) PutAttributes(ctx context.Context, req *PutAttributesRequest) (*PutAttributesResponse, error) {
	// TODO: Implement PutAttributes operation
	return &PutAttributesResponse{}, nil
}

// PutClusterCapacityProviders <p>Modifies the available capacity providers and the default capacity provider strategy
			for a cluster.</p>
         <p>You must specify both the available capacity providers and a default capacity provider
			strategy for the cluster. If the specified cluster has existing capacity providers
			associated with it, you must specify all existing capacity providers in addition to any
			new ones you want to add. Any existing capacity providers that are associated with a
			cluster that are omitted from a <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_PutClusterCapacityProviders.html">PutClusterCapacityProviders</a> API call will be disassociated with the
			cluster. You can only disassociate an existing capacity provider from a cluster if it's
			not being used by any existing tasks.</p>
         <p>When creating a service or running a task on a cluster, if no capacity provider or
			launch type is specified, then the cluster's default capacity provider strategy is used.
			We recommend that you define a default capacity provider strategy for your cluster.
			However, you must specify an empty array (<code>[]</code>) to bypass defining a default
			strategy.</p>
func (s *ECSService) PutClusterCapacityProviders(ctx context.Context, req *PutClusterCapacityProvidersRequest) (*PutClusterCapacityProvidersResponse, error) {
	// TODO: Implement PutClusterCapacityProviders operation
	return &PutClusterCapacityProvidersResponse{}, nil
}

// RegisterContainerInstance <note>
            <p>This action is only used by the Amazon ECS agent, and it is not intended for use outside of the agent.</p>
         </note>
         <p>Registers an EC2 instance into the specified cluster. This instance becomes available
			to place containers on.</p>
func (s *ECSService) RegisterContainerInstance(ctx context.Context, req *RegisterContainerInstanceRequest) (*RegisterContainerInstanceResponse, error) {
	// TODO: Implement RegisterContainerInstance operation
	return &RegisterContainerInstanceResponse{}, nil
}

// RegisterTaskDefinition <p>Registers a new task definition from the supplied <code>family</code> and
				<code>containerDefinitions</code>. Optionally, you can add data volumes to your
			containers with the <code>volumes</code> parameter. For more information about task
			definition parameters and defaults, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_defintions.html">Amazon ECS Task
				Definitions</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
         <p>You can specify a role for your task with the <code>taskRoleArn</code> parameter. When
			you specify a role for a task, its containers can then use the latest versions of the
			CLI or SDKs to make API requests to the Amazon Web Services services that are specified in the
			policy that's associated with the role. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-iam-roles.html">IAM
				Roles for Tasks</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
         <p>You can specify a Docker networking mode for the containers in your task definition
			with the <code>networkMode</code> parameter. If you specify the <code>awsvpc</code>
			network mode, the task is allocated an elastic network interface, and you must specify a
				<a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_NetworkConfiguration.html">NetworkConfiguration</a> when you create a service or run a task with the task
			definition. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking.html">Task Networking</a>
			in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
func (s *ECSService) RegisterTaskDefinition(ctx context.Context, req *RegisterTaskDefinitionRequest) (*RegisterTaskDefinitionResponse, error) {
	// TODO: Implement RegisterTaskDefinition operation
	return &RegisterTaskDefinitionResponse{}, nil
}

// RunTask <p>Starts a new task using the specified task definition.</p>
         <note>
            <p>On March 21, 2024, a change was made to resolve the task definition revision before authorization. When a task definition revision is not specified, authorization will occur using the latest revision of a task definition.</p>
         </note>
         <note>
            <p>Amazon Elastic Inference (EI) is no longer available to customers.</p>
         </note>
         <p>You can allow Amazon ECS to place tasks for you, or you can customize how Amazon ECS places
			tasks using placement constraints and placement strategies. For more information, see
				<a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/scheduling_tasks.html">Scheduling Tasks</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
         <p>Alternatively, you can use <code>StartTask</code> to use your own scheduler or place
			tasks manually on specific container instances.</p>
         <p>You can attach Amazon EBS volumes to Amazon ECS tasks by configuring the volume when creating or
			updating a service. For more infomation, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ebs-volumes.html#ebs-volume-types">Amazon EBS volumes</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
         <p>The Amazon ECS API follows an eventual consistency model. This is because of the
			distributed nature of the system supporting the API. This means that the result of an
			API command you run that affects your Amazon ECS resources might not be immediately visible
			to all subsequent commands you run. Keep this in mind when you carry out an API command
			that immediately follows a previous API command.</p>
         <p>To manage eventual consistency, you can do the following:</p>
         <ul>
            <li>
               <p>Confirm the state of the resource before you run a command to modify it. Run
					the DescribeTasks command using an exponential backoff algorithm to ensure that
					you allow enough time for the previous command to propagate through the system.
					To do this, run the DescribeTasks command repeatedly, starting with a couple of
					seconds of wait time and increasing gradually up to five minutes of wait
					time.</p>
            </li>
            <li>
               <p>Add wait time between subsequent commands, even if the DescribeTasks command
					returns an accurate response. Apply an exponential backoff algorithm starting
					with a couple of seconds of wait time, and increase gradually up to about five
					minutes of wait time.</p>
            </li>
         </ul>
         <p>If you get a <code>ConflictException</code> error, the <code>RunTask</code> request could
			not be processed due to conflicts. The provided <code>clientToken</code> is already in
			use with a different <code>RunTask</code> request. The <code>resourceIds</code> are the
			existing task ARNs which are already associated with the <code>clientToken</code>. </p>
         <p>To fix this issue:</p>
         <ul>
            <li>
               <p>Run <code>RunTask</code> with a unique <code>clientToken</code>.</p>
            </li>
            <li>
               <p>Run <code>RunTask</code> with the <code>clientToken</code> and the original
					set of parameters</p>
            </li>
         </ul>
         <p>If you get a <code>ClientException</code>error, the <code>RunTask</code> could not be processed because you use managed
					scaling and there is a capacity error because the quota of tasks in the
					<code>PROVISIONING</code> per cluster has been reached. For information
					about the service quotas, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-quotas.html">Amazon ECS
						service quotas</a>.</p>
func (s *ECSService) RunTask(ctx context.Context, req *RunTaskRequest) (*RunTaskResponse, error) {
	// TODO: Implement RunTask operation
	return &RunTaskResponse{}, nil
}

// StartTask <p>Starts a new task from the specified task definition on the specified container
			instance or instances.</p>
         <note>
            <p>On March 21, 2024, a change was made to resolve the task definition revision before authorization. When a task definition revision is not specified, authorization will occur using the latest revision of a task definition.</p>
         </note>
         <note>
            <p>Amazon Elastic Inference (EI) is no longer available to customers.</p>
         </note>
         <p>Alternatively, you can use<code>RunTask</code> to place tasks for you. For more
			information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/scheduling_tasks.html">Scheduling Tasks</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
         <p>You can attach Amazon EBS volumes to Amazon ECS tasks by configuring the volume when creating or
			updating a service. For more infomation, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ebs-volumes.html#ebs-volume-types">Amazon EBS volumes</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
func (s *ECSService) StartTask(ctx context.Context, req *StartTaskRequest) (*StartTaskResponse, error) {
	// TODO: Implement StartTask operation
	return &StartTaskResponse{}, nil
}

// StopServiceDeployment <p>Stops an ongoing service deployment.</p>
         <p>The following stop types are avaiable:</p>
         <ul>
            <li>
               <p>ROLLBACK - This option rolls back the service deployment to the previous
					service revision. </p>
               <p>You can use this option even if you didn't configure the service deployment
					for the rollback option. </p>
            </li>
         </ul>
         <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/stop-service-deployment.html">Stopping Amazon ECS
				service deployments</a> in the <i>Amazon Elastic Container Service Developer
			Guide</i>.</p>
func (s *ECSService) StopServiceDeployment(ctx context.Context, req *StopServiceDeploymentRequest) (*StopServiceDeploymentResponse, error) {
	// TODO: Implement StopServiceDeployment operation
	return &StopServiceDeploymentResponse{}, nil
}

// StopTask <p>Stops a running task. Any tags associated with the task will be deleted.</p>
         <p>When you call <code>StopTask</code> on a task, the equivalent of <code>docker
				stop</code> is issued to the containers running in the task. This results in a
				<code>SIGTERM</code> value and a default 30-second timeout, after which the
				<code>SIGKILL</code> value is sent and the containers are forcibly stopped. If the
			container handles the <code>SIGTERM</code> value gracefully and exits within 30 seconds
			from receiving it, no <code>SIGKILL</code> value is sent.</p>
         <p>For Windows containers, POSIX signals do not work and runtime stops the container by
			sending a <code>CTRL_SHUTDOWN_EVENT</code>. For more information, see <a href="https://github.com/moby/moby/issues/25982">Unable to react to graceful shutdown
				of (Windows) container #25982</a> on GitHub.</p>
         <note>
            <p>The default 30-second timeout can be configured on the Amazon ECS container agent with
				the <code>ECS_CONTAINER_STOP_TIMEOUT</code> variable. For more information, see
					<a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-agent-config.html">Amazon ECS Container Agent Configuration</a> in the
				<i>Amazon Elastic Container Service Developer Guide</i>.</p>
         </note>
func (s *ECSService) StopTask(ctx context.Context, req *StopTaskRequest) (*StopTaskResponse, error) {
	// TODO: Implement StopTask operation
	return &StopTaskResponse{}, nil
}

// SubmitAttachmentStateChanges <note>
            <p>This action is only used by the Amazon ECS agent, and it is not intended for use outside of the agent.</p>
         </note>
         <p>Sent to acknowledge that an attachment changed states.</p>
func (s *ECSService) SubmitAttachmentStateChanges(ctx context.Context, req *SubmitAttachmentStateChangesRequest) (*SubmitAttachmentStateChangesResponse, error) {
	// TODO: Implement SubmitAttachmentStateChanges operation
	return &SubmitAttachmentStateChangesResponse{}, nil
}

// SubmitContainerStateChange <note>
            <p>This action is only used by the Amazon ECS agent, and it is not intended for use outside of the agent.</p>
         </note>
         <p>Sent to acknowledge that a container changed states.</p>
func (s *ECSService) SubmitContainerStateChange(ctx context.Context, req *SubmitContainerStateChangeRequest) (*SubmitContainerStateChangeResponse, error) {
	// TODO: Implement SubmitContainerStateChange operation
	return &SubmitContainerStateChangeResponse{}, nil
}

// SubmitTaskStateChange <note>
            <p>This action is only used by the Amazon ECS agent, and it is not intended for use outside of the agent.</p>
         </note>
         <p>Sent to acknowledge that a task changed states.</p>
func (s *ECSService) SubmitTaskStateChange(ctx context.Context, req *SubmitTaskStateChangeRequest) (*SubmitTaskStateChangeResponse, error) {
	// TODO: Implement SubmitTaskStateChange operation
	return &SubmitTaskStateChangeResponse{}, nil
}

// TagResource <p>Associates the specified tags to a resource with the specified
				<code>resourceArn</code>. If existing tags on a resource aren't specified in the
			request parameters, they aren't changed. When a resource is deleted, the tags that are
			associated with that resource are deleted as well.</p>
func (s *ECSService) TagResource(ctx context.Context, req *TagResourceRequest) (*TagResourceResponse, error) {
	// TODO: Implement TagResource operation
	return &TagResourceResponse{}, nil
}

// UntagResource <p>Deletes specified tags from a resource.</p>
func (s *ECSService) UntagResource(ctx context.Context, req *UntagResourceRequest) (*UntagResourceResponse, error) {
	// TODO: Implement UntagResource operation
	return &UntagResourceResponse{}, nil
}

// UpdateCapacityProvider <p>Modifies the parameters for a capacity provider.</p>
func (s *ECSService) UpdateCapacityProvider(ctx context.Context, req *UpdateCapacityProviderRequest) (*UpdateCapacityProviderResponse, error) {
	// TODO: Implement UpdateCapacityProvider operation
	return &UpdateCapacityProviderResponse{}, nil
}

// UpdateCluster <p>Updates the cluster.</p>
func (s *ECSService) UpdateCluster(ctx context.Context, req *UpdateClusterRequest) (*UpdateClusterResponse, error) {
	// TODO: Implement UpdateCluster operation
	return &UpdateClusterResponse{}, nil
}

// UpdateClusterSettings <p>Modifies the settings to use for a cluster.</p>
func (s *ECSService) UpdateClusterSettings(ctx context.Context, req *UpdateClusterSettingsRequest) (*UpdateClusterSettingsResponse, error) {
	// TODO: Implement UpdateClusterSettings operation
	return &UpdateClusterSettingsResponse{}, nil
}

// UpdateContainerAgent <p>Updates the Amazon ECS container agent on a specified container instance. Updating the
			Amazon ECS container agent doesn't interrupt running tasks or services on the container
			instance. The process for updating the agent differs depending on whether your container
			instance was launched with the Amazon ECS-optimized AMI or another operating system.</p>
         <note>
            <p>The <code>UpdateContainerAgent</code> API isn't supported for container instances
				using the Amazon ECS-optimized Amazon Linux 2 (arm64) AMI. To update the container agent,
				you can update the <code>ecs-init</code> package. This updates the agent. For more
				information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/agent-update-ecs-ami.html">Updating the
					Amazon ECS container agent</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
         </note>
         <note>
            <p>Agent updates with the <code>UpdateContainerAgent</code> API operation do not
				apply to Windows container instances. We recommend that you launch new container
				instances to update the agent version in your Windows clusters.</p>
         </note>
         <p>The <code>UpdateContainerAgent</code> API requires an Amazon ECS-optimized AMI or Amazon
			Linux AMI with the <code>ecs-init</code> service installed and running. For help
			updating the Amazon ECS container agent on other operating systems, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-agent-update.html#manually_update_agent">Manually updating the Amazon ECS container agent</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
func (s *ECSService) UpdateContainerAgent(ctx context.Context, req *UpdateContainerAgentRequest) (*UpdateContainerAgentResponse, error) {
	// TODO: Implement UpdateContainerAgent operation
	return &UpdateContainerAgentResponse{}, nil
}

// UpdateContainerInstancesState <p>Modifies the status of an Amazon ECS container instance.</p>
         <p>Once a container instance has reached an <code>ACTIVE</code> state, you can change the
			status of a container instance to <code>DRAINING</code> to manually remove an instance
			from a cluster, for example to perform system updates, update the Docker daemon, or
			scale down the cluster size.</p>
         <important>
            <p>A container instance can't be changed to <code>DRAINING</code> until it has
				reached an <code>ACTIVE</code> status. If the instance is in any other status, an
				error will be received.</p>
         </important>
         <p>When you set a container instance to <code>DRAINING</code>, Amazon ECS prevents new tasks
			from being scheduled for placement on the container instance and replacement service
			tasks are started on other container instances in the cluster if the resources are
			available. Service tasks on the container instance that are in the <code>PENDING</code>
			state are stopped immediately.</p>
         <p>Service tasks on the container instance that are in the <code>RUNNING</code> state are
			stopped and replaced according to the service's deployment configuration parameters,
				<code>minimumHealthyPercent</code> and <code>maximumPercent</code>. You can change
			the deployment configuration of your service using <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_UpdateService.html">UpdateService</a>.</p>
         <ul>
            <li>
               <p>If <code>minimumHealthyPercent</code> is below 100%, the scheduler can ignore
						<code>desiredCount</code> temporarily during task replacement. For example,
						<code>desiredCount</code> is four tasks, a minimum of 50% allows the
					scheduler to stop two existing tasks before starting two new tasks. If the
					minimum is 100%, the service scheduler can't remove existing tasks until the
					replacement tasks are considered healthy. Tasks for services that do not use a
					load balancer are considered healthy if they're in the <code>RUNNING</code>
					state. Tasks for services that use a load balancer are considered healthy if
					they're in the <code>RUNNING</code> state and are reported as healthy by the
					load balancer.</p>
            </li>
            <li>
               <p>The <code>maximumPercent</code> parameter represents an upper limit on the
					number of running tasks during task replacement. You can use this to define the
					replacement batch size. For example, if <code>desiredCount</code> is four tasks,
					a maximum of 200% starts four new tasks before stopping the four tasks to be
					drained, provided that the cluster resources required to do this are available.
					If the maximum is 100%, then replacement tasks can't start until the draining
					tasks have stopped.</p>
            </li>
         </ul>
         <p>Any <code>PENDING</code> or <code>RUNNING</code> tasks that do not belong to a service
			aren't affected. You must wait for them to finish or stop them manually.</p>
         <p>A container instance has completed draining when it has no more <code>RUNNING</code>
			tasks. You can verify this using <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ListTasks.html">ListTasks</a>.</p>
         <p>When a container instance has been drained, you can set a container instance to
				<code>ACTIVE</code> status and once it has reached that status the Amazon ECS scheduler
			can begin scheduling tasks on the instance again.</p>
func (s *ECSService) UpdateContainerInstancesState(ctx context.Context, req *UpdateContainerInstancesStateRequest) (*UpdateContainerInstancesStateResponse, error) {
	// TODO: Implement UpdateContainerInstancesState operation
	return &UpdateContainerInstancesStateResponse{}, nil
}

// UpdateService <p>Modifies the parameters of a service.</p>
         <note>
            <p>On March 21, 2024, a change was made to resolve the task definition revision before authorization. When a task definition revision is not specified, authorization will occur using the latest revision of a task definition.</p>
         </note>
         <p>For services using the rolling update (<code>ECS</code>) you can update the desired
			count, deployment configuration, network configuration, load balancers, service
			registries, enable ECS managed tags option, propagate tags option, task placement
			constraints and strategies, and task definition. When you update any of these
			parameters, Amazon ECS starts new tasks with the new configuration. </p>
         <p>You can attach Amazon EBS volumes to Amazon ECS tasks by configuring the volume when starting or
			running a task, or when creating or updating a service. For more infomation, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ebs-volumes.html#ebs-volume-types">Amazon EBS volumes</a> in the <i>Amazon Elastic Container Service Developer Guide</i>. You can update
			your volume configurations and trigger a new deployment.
				<code>volumeConfigurations</code> is only supported for REPLICA service and not
			DAEMON service. If you leave <code>volumeConfigurations</code>
            <code>null</code>, it doesn't trigger a new deployment. For more infomation on volumes,
			see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ebs-volumes.html#ebs-volume-types">Amazon EBS volumes</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
         <p>For services using the blue/green (<code>CODE_DEPLOY</code>) deployment controller,
			only the desired count, deployment configuration, health check grace period, task
			placement constraints and strategies, enable ECS managed tags option, and propagate tags
			can be updated using this API. If the network configuration, platform version, task
			definition, or load balancer need to be updated, create a new CodeDeploy deployment. For more
			information, see <a href="https://docs.aws.amazon.com/codedeploy/latest/APIReference/API_CreateDeployment.html">CreateDeployment</a> in the <i>CodeDeploy API Reference</i>.</p>
         <p>For services using an external deployment controller, you can update only the desired
			count, task placement constraints and strategies, health check grace period, enable ECS
			managed tags option, and propagate tags option, using this API. If the launch type, load
			balancer, network configuration, platform version, or task definition need to be
			updated, create a new task set For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_CreateTaskSet.html">CreateTaskSet</a>.</p>
         <p>You can add to or subtract from the number of instantiations of a task definition in a
			service by specifying the cluster that the service is running in and a new
				<code>desiredCount</code> parameter.</p>
         <p>You can attach Amazon EBS volumes to Amazon ECS tasks by configuring the volume when starting or
			running a task, or when creating or updating a service. For more infomation, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ebs-volumes.html#ebs-volume-types">Amazon EBS volumes</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
         <p>If you have updated the container image of your application, you can create a new task
			definition with that image and deploy it to your service. The service scheduler uses the
			minimum healthy percent and maximum percent parameters (in the service's deployment
			configuration) to determine the deployment strategy.</p>
         <note>
            <p>If your updated Docker image uses the same tag as what is in the existing task
				definition for your service (for example, <code>my_image:latest</code>), you don't
				need to create a new revision of your task definition. You can update the service
				using the <code>forceNewDeployment</code> option. The new tasks launched by the
				deployment pull the current image/tag combination from your repository when they
				start.</p>
         </note>
         <p>You can also update the deployment configuration of a service. When a deployment is
			triggered by updating the task definition of a service, the service scheduler uses the
			deployment configuration parameters, <code>minimumHealthyPercent</code> and
				<code>maximumPercent</code>, to determine the deployment strategy.</p>
         <ul>
            <li>
               <p>If <code>minimumHealthyPercent</code> is below 100%, the scheduler can ignore
						<code>desiredCount</code> temporarily during a deployment. For example, if
						<code>desiredCount</code> is four tasks, a minimum of 50% allows the
					scheduler to stop two existing tasks before starting two new tasks. Tasks for
					services that don't use a load balancer are considered healthy if they're in the
						<code>RUNNING</code> state. Tasks for services that use a load balancer are
					considered healthy if they're in the <code>RUNNING</code> state and are reported
					as healthy by the load balancer.</p>
            </li>
            <li>
               <p>The <code>maximumPercent</code> parameter represents an upper limit on the
					number of running tasks during a deployment. You can use it to define the
					deployment batch size. For example, if <code>desiredCount</code> is four tasks,
					a maximum of 200% starts four new tasks before stopping the four older tasks
					(provided that the cluster resources required to do this are available).</p>
            </li>
         </ul>
         <p>When <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_UpdateService.html">UpdateService</a>
			stops a task during a deployment, the equivalent of <code>docker stop</code> is issued
			to the containers running in the task. This results in a <code>SIGTERM</code> and a
			30-second timeout. After this, <code>SIGKILL</code> is sent and the containers are
			forcibly stopped. If the container handles the <code>SIGTERM</code> gracefully and exits
			within 30 seconds from receiving it, no <code>SIGKILL</code> is sent.</p>
         <p>When the service scheduler launches new tasks, it determines task placement in your
			cluster with the following logic.</p>
         <ul>
            <li>
               <p>Determine which of the container instances in your cluster can support your
					service's task definition. For example, they have the required CPU, memory,
					ports, and container instance attributes.</p>
            </li>
            <li>
               <p>By default, the service scheduler attempts to balance tasks across
					Availability Zones in this manner even though you can choose a different
					placement strategy.</p>
               <ul>
                  <li>
                     <p>Sort the valid container instances by the fewest number of running
							tasks for this service in the same Availability Zone as the instance.
							For example, if zone A has one running service task and zones B and C
							each have zero, valid container instances in either zone B or C are
							considered optimal for placement.</p>
                  </li>
                  <li>
                     <p>Place the new service task on a valid container instance in an optimal
							Availability Zone (based on the previous steps), favoring container
							instances with the fewest number of running tasks for this
							service.</p>
                  </li>
               </ul>
            </li>
         </ul>
         <p>When the service scheduler stops running tasks, it attempts to maintain balance across
			the Availability Zones in your cluster using the following logic: </p>
         <ul>
            <li>
               <p>Sort the container instances by the largest number of running tasks for this
					service in the same Availability Zone as the instance. For example, if zone A
					has one running service task and zones B and C each have two, container
					instances in either zone B or C are considered optimal for termination.</p>
            </li>
            <li>
               <p>Stop the task on a container instance in an optimal Availability Zone (based
					on the previous steps), favoring container instances with the largest number of
					running tasks for this service.</p>
            </li>
         </ul>
         <note>
            <p>You must have a service-linked role when you update any of the following service
				properties:</p>
            <ul>
               <li>
                  <p>
                     <code>loadBalancers</code>,</p>
               </li>
               <li>
                  <p>
                     <code>serviceRegistries</code>
                  </p>
               </li>
            </ul>
            <p>For more information about the role see the <code>CreateService</code> request
				parameter <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_CreateService.html#ECS-CreateService-request-role">
                  <code>role</code>
               </a>. </p>
         </note>
func (s *ECSService) UpdateService(ctx context.Context, req *UpdateServiceRequest) (*UpdateServiceResponse, error) {
	// TODO: Implement UpdateService operation
	return &UpdateServiceResponse{}, nil
}

// UpdateServicePrimaryTaskSet <p>Modifies which task set in a service is the primary task set. Any parameters that are
			updated on the primary task set in a service will transition to the service. This is
			used when a service uses the <code>EXTERNAL</code> deployment controller type. For more
			information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html">Amazon ECS Deployment
				Types</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
func (s *ECSService) UpdateServicePrimaryTaskSet(ctx context.Context, req *UpdateServicePrimaryTaskSetRequest) (*UpdateServicePrimaryTaskSetResponse, error) {
	// TODO: Implement UpdateServicePrimaryTaskSet operation
	return &UpdateServicePrimaryTaskSetResponse{}, nil
}

// UpdateTaskProtection <p>Updates the protection status of a task. You can set <code>protectionEnabled</code> to
				<code>true</code> to protect your task from termination during scale-in events from
				<a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-auto-scaling.html">Service
				Autoscaling</a> or <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html">deployments</a>.</p>
         <p>Task-protection, by default, expires after 2 hours at which point Amazon ECS clears the
				<code>protectionEnabled</code> property making the task eligible for termination by
			a subsequent scale-in event.</p>
         <p>You can specify a custom expiration period for task protection from 1 minute to up to
			2,880 minutes (48 hours). To specify the custom expiration period, set the
				<code>expiresInMinutes</code> property. The <code>expiresInMinutes</code> property
			is always reset when you invoke this operation for a task that already has
				<code>protectionEnabled</code> set to <code>true</code>. You can keep extending the
			protection expiration period of a task by invoking this operation repeatedly.</p>
         <p>To learn more about Amazon ECS task protection, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-scale-in-protection.html">Task scale-in
				protection</a> in the <i>
               <i>Amazon Elastic Container Service Developer Guide</i>
            </i>.</p>
         <note>
            <p>This operation is only supported for tasks belonging to an Amazon ECS service. Invoking
				this operation for a standalone task will result in an <code>TASK_NOT_VALID</code>
				failure. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/api_failures_messages.html">API failure
					reasons</a>.</p>
         </note>
         <important>
            <p>If you prefer to set task protection from within the container, we recommend using
				the <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-scale-in-protection-endpoint.html">Task scale-in protection endpoint</a>.</p>
         </important>
func (s *ECSService) UpdateTaskProtection(ctx context.Context, req *UpdateTaskProtectionRequest) (*UpdateTaskProtectionResponse, error) {
	// TODO: Implement UpdateTaskProtection operation
	return &UpdateTaskProtectionResponse{}, nil
}

// UpdateTaskSet <p>Modifies a task set. This is used when a service uses the <code>EXTERNAL</code>
			deployment controller type. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html">Amazon ECS Deployment
				Types</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
func (s *ECSService) UpdateTaskSet(ctx context.Context, req *UpdateTaskSetRequest) (*UpdateTaskSetResponse, error) {
	// TODO: Implement UpdateTaskSet operation
	return &UpdateTaskSetResponse{}, nil
}

// HTTP handlers for each operation

// HandleCreateCapacityProvider handles HTTP requests for CreateCapacityProvider
func HandleCreateCapacityProvider(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into CreateCapacityProviderRequest
		// TODO: Call service.CreateCapacityProvider(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleCreateCluster handles HTTP requests for CreateCluster
func HandleCreateCluster(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into CreateClusterRequest
		// TODO: Call service.CreateCluster(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleCreateService handles HTTP requests for CreateService
func HandleCreateService(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into CreateServiceRequest
		// TODO: Call service.CreateService(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleCreateTaskSet handles HTTP requests for CreateTaskSet
func HandleCreateTaskSet(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into CreateTaskSetRequest
		// TODO: Call service.CreateTaskSet(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleDeleteAccountSetting handles HTTP requests for DeleteAccountSetting
func HandleDeleteAccountSetting(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into DeleteAccountSettingRequest
		// TODO: Call service.DeleteAccountSetting(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleDeleteAttributes handles HTTP requests for DeleteAttributes
func HandleDeleteAttributes(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into DeleteAttributesRequest
		// TODO: Call service.DeleteAttributes(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleDeleteCapacityProvider handles HTTP requests for DeleteCapacityProvider
func HandleDeleteCapacityProvider(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into DeleteCapacityProviderRequest
		// TODO: Call service.DeleteCapacityProvider(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleDeleteCluster handles HTTP requests for DeleteCluster
func HandleDeleteCluster(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into DeleteClusterRequest
		// TODO: Call service.DeleteCluster(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleDeleteService handles HTTP requests for DeleteService
func HandleDeleteService(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into DeleteServiceRequest
		// TODO: Call service.DeleteService(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleDeleteTaskDefinitions handles HTTP requests for DeleteTaskDefinitions
func HandleDeleteTaskDefinitions(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into DeleteTaskDefinitionsRequest
		// TODO: Call service.DeleteTaskDefinitions(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleDeleteTaskSet handles HTTP requests for DeleteTaskSet
func HandleDeleteTaskSet(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into DeleteTaskSetRequest
		// TODO: Call service.DeleteTaskSet(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleDeregisterContainerInstance handles HTTP requests for DeregisterContainerInstance
func HandleDeregisterContainerInstance(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into DeregisterContainerInstanceRequest
		// TODO: Call service.DeregisterContainerInstance(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleDeregisterTaskDefinition handles HTTP requests for DeregisterTaskDefinition
func HandleDeregisterTaskDefinition(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into DeregisterTaskDefinitionRequest
		// TODO: Call service.DeregisterTaskDefinition(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleDescribeCapacityProviders handles HTTP requests for DescribeCapacityProviders
func HandleDescribeCapacityProviders(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into DescribeCapacityProvidersRequest
		// TODO: Call service.DescribeCapacityProviders(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleDescribeClusters handles HTTP requests for DescribeClusters
func HandleDescribeClusters(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into DescribeClustersRequest
		// TODO: Call service.DescribeClusters(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleDescribeContainerInstances handles HTTP requests for DescribeContainerInstances
func HandleDescribeContainerInstances(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into DescribeContainerInstancesRequest
		// TODO: Call service.DescribeContainerInstances(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleDescribeServiceDeployments handles HTTP requests for DescribeServiceDeployments
func HandleDescribeServiceDeployments(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into DescribeServiceDeploymentsRequest
		// TODO: Call service.DescribeServiceDeployments(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleDescribeServiceRevisions handles HTTP requests for DescribeServiceRevisions
func HandleDescribeServiceRevisions(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into DescribeServiceRevisionsRequest
		// TODO: Call service.DescribeServiceRevisions(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleDescribeServices handles HTTP requests for DescribeServices
func HandleDescribeServices(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into DescribeServicesRequest
		// TODO: Call service.DescribeServices(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleDescribeTaskDefinition handles HTTP requests for DescribeTaskDefinition
func HandleDescribeTaskDefinition(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into DescribeTaskDefinitionRequest
		// TODO: Call service.DescribeTaskDefinition(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleDescribeTaskSets handles HTTP requests for DescribeTaskSets
func HandleDescribeTaskSets(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into DescribeTaskSetsRequest
		// TODO: Call service.DescribeTaskSets(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleDescribeTasks handles HTTP requests for DescribeTasks
func HandleDescribeTasks(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into DescribeTasksRequest
		// TODO: Call service.DescribeTasks(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleDiscoverPollEndpoint handles HTTP requests for DiscoverPollEndpoint
func HandleDiscoverPollEndpoint(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into DiscoverPollEndpointRequest
		// TODO: Call service.DiscoverPollEndpoint(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleExecuteCommand handles HTTP requests for ExecuteCommand
func HandleExecuteCommand(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into ExecuteCommandRequest
		// TODO: Call service.ExecuteCommand(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleGetTaskProtection handles HTTP requests for GetTaskProtection
func HandleGetTaskProtection(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into GetTaskProtectionRequest
		// TODO: Call service.GetTaskProtection(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleListAccountSettings handles HTTP requests for ListAccountSettings
func HandleListAccountSettings(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into ListAccountSettingsRequest
		// TODO: Call service.ListAccountSettings(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleListAttributes handles HTTP requests for ListAttributes
func HandleListAttributes(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into ListAttributesRequest
		// TODO: Call service.ListAttributes(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleListClusters handles HTTP requests for ListClusters
func HandleListClusters(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into ListClustersRequest
		// TODO: Call service.ListClusters(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleListContainerInstances handles HTTP requests for ListContainerInstances
func HandleListContainerInstances(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into ListContainerInstancesRequest
		// TODO: Call service.ListContainerInstances(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleListServiceDeployments handles HTTP requests for ListServiceDeployments
func HandleListServiceDeployments(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into ListServiceDeploymentsRequest
		// TODO: Call service.ListServiceDeployments(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleListServices handles HTTP requests for ListServices
func HandleListServices(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into ListServicesRequest
		// TODO: Call service.ListServices(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleListServicesByNamespace handles HTTP requests for ListServicesByNamespace
func HandleListServicesByNamespace(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into ListServicesByNamespaceRequest
		// TODO: Call service.ListServicesByNamespace(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleListTagsForResource handles HTTP requests for ListTagsForResource
func HandleListTagsForResource(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into ListTagsForResourceRequest
		// TODO: Call service.ListTagsForResource(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleListTaskDefinitionFamilies handles HTTP requests for ListTaskDefinitionFamilies
func HandleListTaskDefinitionFamilies(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into ListTaskDefinitionFamiliesRequest
		// TODO: Call service.ListTaskDefinitionFamilies(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleListTaskDefinitions handles HTTP requests for ListTaskDefinitions
func HandleListTaskDefinitions(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into ListTaskDefinitionsRequest
		// TODO: Call service.ListTaskDefinitions(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleListTasks handles HTTP requests for ListTasks
func HandleListTasks(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into ListTasksRequest
		// TODO: Call service.ListTasks(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandlePutAccountSetting handles HTTP requests for PutAccountSetting
func HandlePutAccountSetting(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into PutAccountSettingRequest
		// TODO: Call service.PutAccountSetting(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandlePutAccountSettingDefault handles HTTP requests for PutAccountSettingDefault
func HandlePutAccountSettingDefault(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into PutAccountSettingDefaultRequest
		// TODO: Call service.PutAccountSettingDefault(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandlePutAttributes handles HTTP requests for PutAttributes
func HandlePutAttributes(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into PutAttributesRequest
		// TODO: Call service.PutAttributes(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandlePutClusterCapacityProviders handles HTTP requests for PutClusterCapacityProviders
func HandlePutClusterCapacityProviders(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into PutClusterCapacityProvidersRequest
		// TODO: Call service.PutClusterCapacityProviders(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleRegisterContainerInstance handles HTTP requests for RegisterContainerInstance
func HandleRegisterContainerInstance(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into RegisterContainerInstanceRequest
		// TODO: Call service.RegisterContainerInstance(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleRegisterTaskDefinition handles HTTP requests for RegisterTaskDefinition
func HandleRegisterTaskDefinition(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into RegisterTaskDefinitionRequest
		// TODO: Call service.RegisterTaskDefinition(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleRunTask handles HTTP requests for RunTask
func HandleRunTask(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into RunTaskRequest
		// TODO: Call service.RunTask(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleStartTask handles HTTP requests for StartTask
func HandleStartTask(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into StartTaskRequest
		// TODO: Call service.StartTask(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleStopServiceDeployment handles HTTP requests for StopServiceDeployment
func HandleStopServiceDeployment(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into StopServiceDeploymentRequest
		// TODO: Call service.StopServiceDeployment(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleStopTask handles HTTP requests for StopTask
func HandleStopTask(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into StopTaskRequest
		// TODO: Call service.StopTask(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleSubmitAttachmentStateChanges handles HTTP requests for SubmitAttachmentStateChanges
func HandleSubmitAttachmentStateChanges(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into SubmitAttachmentStateChangesRequest
		// TODO: Call service.SubmitAttachmentStateChanges(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleSubmitContainerStateChange handles HTTP requests for SubmitContainerStateChange
func HandleSubmitContainerStateChange(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into SubmitContainerStateChangeRequest
		// TODO: Call service.SubmitContainerStateChange(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleSubmitTaskStateChange handles HTTP requests for SubmitTaskStateChange
func HandleSubmitTaskStateChange(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into SubmitTaskStateChangeRequest
		// TODO: Call service.SubmitTaskStateChange(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleTagResource handles HTTP requests for TagResource
func HandleTagResource(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into TagResourceRequest
		// TODO: Call service.TagResource(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleUntagResource handles HTTP requests for UntagResource
func HandleUntagResource(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into UntagResourceRequest
		// TODO: Call service.UntagResource(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleUpdateCapacityProvider handles HTTP requests for UpdateCapacityProvider
func HandleUpdateCapacityProvider(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into UpdateCapacityProviderRequest
		// TODO: Call service.UpdateCapacityProvider(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleUpdateCluster handles HTTP requests for UpdateCluster
func HandleUpdateCluster(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into UpdateClusterRequest
		// TODO: Call service.UpdateCluster(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleUpdateClusterSettings handles HTTP requests for UpdateClusterSettings
func HandleUpdateClusterSettings(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into UpdateClusterSettingsRequest
		// TODO: Call service.UpdateClusterSettings(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleUpdateContainerAgent handles HTTP requests for UpdateContainerAgent
func HandleUpdateContainerAgent(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into UpdateContainerAgentRequest
		// TODO: Call service.UpdateContainerAgent(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleUpdateContainerInstancesState handles HTTP requests for UpdateContainerInstancesState
func HandleUpdateContainerInstancesState(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into UpdateContainerInstancesStateRequest
		// TODO: Call service.UpdateContainerInstancesState(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleUpdateService handles HTTP requests for UpdateService
func HandleUpdateService(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into UpdateServiceRequest
		// TODO: Call service.UpdateService(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleUpdateServicePrimaryTaskSet handles HTTP requests for UpdateServicePrimaryTaskSet
func HandleUpdateServicePrimaryTaskSet(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into UpdateServicePrimaryTaskSetRequest
		// TODO: Call service.UpdateServicePrimaryTaskSet(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleUpdateTaskProtection handles HTTP requests for UpdateTaskProtection
func HandleUpdateTaskProtection(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into UpdateTaskProtectionRequest
		// TODO: Call service.UpdateTaskProtection(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}

// HandleUpdateTaskSet handles HTTP requests for UpdateTaskSet
func HandleUpdateTaskSet(service ECSServiceInterface) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: Parse request body into UpdateTaskSetRequest
		// TODO: Call service.UpdateTaskSet(ctx, req)
		// TODO: Write response as JSON
		w.Header().Set("Content-Type", "application/x-amz-json-1.1")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("{}"))
	}
}
